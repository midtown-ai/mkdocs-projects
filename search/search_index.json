{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Projects","text":"<ul> <li> <p> Python</p> <p>Python is a versatile, high-level programming language known for its simplicity and readability. It\u2019s widely used in web development, automation, data science, AI, and more. With an extensive library ecosystem and strong community support, Python is a great choice for beginners and experienced developers alike.</p> <p> Explore python</p> </li> <li> <p> DeepRacer</p> <p>AWS DeepRacer is an autonomous racing platform that allows developers to get hands-on with reinforcement learning. Train, evaluate, and compete in global racing leagues using a 1/18th scale autonomous car in a simulated or physical environment. Whether you're a beginner or an AI enthusiast, DeepRacer provides an exciting way to explore machine learning in action.</p> <p> Let's DeepRacer!</p> </li> <li> <p> Pytorch</p> <p>PyTorch is a powerful open-source deep learning framework designed for research and production. With its dynamic computation graph and intuitive API, PyTorch is widely used for building neural networks, performing AI research, and deploying machine learning models. Whether you're training vision, NLP, or reinforcement learning models, PyTorch offers the flexibility and efficiency needed for cutting-edge AI applications.</p> <p> Get started with PyTorch</p> </li> <li> <p> Seaborn</p> <p>Seaborn is a powerful Python data visualization library built on top of Matplotlib. It makes creating beautiful, informative charts effortless, with built-in themes, color palettes, and statistical functions. Whether you\u2019re working with histograms, heatmaps, or regression plots, Seaborn simplifies complex visualizations with just a few lines of code.</p> <p>Why use Seaborn? Elegant &amp; Aesthetic Graphs, Seamless Pandas Integration, Easy Statistical Visualization, Automatic Data Aggregation.</p> <p> Want to master Seaborn ?</p> </li> </ul>"},{"location":"python/","title":"Python Fundamentals","text":""},{"location":"python/#glossary","title":"Glossary","text":"Concurrency <p>Concurrency is concerned with managing access to shared state from different threads. Beware concurrency and parallelism are distinct concepts. Parallelism is concerned with utilizing multiple processors/cores to improve the performance of a computation. </p> Container Object <p>Some objects contain references to other objects, these objects are called containers. Some examples of container-objects are a tuple, list, and dictionary. The value of an immutable container that contains a reference to a mutable object can be changed if that mutable object is changed. However, the container is still considered immutable because when we talk about the mutability of a container only the identities of the contained objects are implied. <pre><code>&gt;&gt;&gt; t = ([1,2], [0])           # a tuple of 2 lists\n&gt;&gt;&gt; t[0].append(3)             # the list are mutable containers !\n&gt;&gt;&gt; t\n([1, 2, 3], [0])\n</code></pre></p> <p>But <pre><code>&gt;&gt;&gt; t[0] = 1                   # ... but the tuple is not a mutable container, so id(t[0]) cannot change !\nTypeError: 'tuple' object does not support item assignment\n</code></pre></p> <p>See also Mutability</p> Decorator <p>A function that takes a function as input and return another function!  decorators wrap a function, modifying its behavior. i.e the return function is assigned to the initial function variable ! <pre><code>my_function = my_decorator(my_function)\n</code></pre></p> Deep Copy  <p>A deep copy duplicates not just the outer object (like a list), but also all the nested mutable objects inside it. In contrast, a shallow copy only duplicates the outer container \u2014 the inner elements are still references to the same objects. <pre><code>import copy\n\noriginal = [[1, 2], [3, 4]]\n\nshallow = copy.copy(original)   # Could also be original[:] if original is a sequence\n                                # or original.copy() if object supports it (lists, dicts, sets only)\n                                # copy.copy is for any object that supports it!\ndeep = copy.deepcopy(original)\n\n# Change an inner value\noriginal[0][0] = 99\n\nprint(\"Original:\", original)   # [[99, 2], [3, 4]]\nprint(\"Shallow:\", shallow)     # [[99, 2], [3, 4]] \u2014 changed!\nprint(\"Deep:\", deep)           # [[1, 2], [3, 4]] \u2014 unchanged \u2705\n</code></pre></p> Global Interpreter Lock (GIL) <p>The Python threading module uses threads instead of processes. Threads run in the same unique memory heap. Whereas Processes run in separate memory heaps. This, makes sharing information harder with processes and object instances. One problem arises because threads use the same memory heap, multiple threads can write to the same location in the memory heap which is why the default Python interpreter has a thread-safe mechanism, the \u201cGIL\u201d (Global Interpreter Lock). This prevent conflicts between threads, by executing only one statement at a time (serial processing, or single-threading).</p> <p>The Global Interpretor Lock (GIL) in CPython prevents parallel threads of execution on multiple cores, thus the threading implementation on python is useful mostly for concurrent thread implementation in web-servers.</p> <p>More at https://blog.usejournal.com/multithreading-vs-multiprocessing-in-python-c7dc88b50b5b</p> Identity <p>~ pointer to memory area (memory address)??? An object as a type, value, and identity -- type and identity of the object stays constant! In Python, a reference is not directly exposed, but you can work with it using the object's memory address (id()) or weak references. <pre><code>&gt;&gt;&gt; id([1,2])\n4382416128\n&gt;&gt;&gt; id([1,2])\n4382416128\n&gt;&gt;&gt; a = [1,2]               &lt;== variable\n&gt;&gt;&gt; id([1,2])\n4382422528\n&gt;&gt;&gt; id(a)                   &lt;== variable points to the identity of the assigned object, the identity is used by variables and container objects\n4382416128\n</code></pre> <pre><code>&gt;&gt;&gt; s = 'hello'\n&gt;&gt;&gt; id(s)\n4384848624\n&gt;&gt;&gt; sorted(s)\n['e', 'h', 'l', 'l', 'o']\n&gt;&gt;&gt; id(s)\n4384848624\n&gt;&gt;&gt; id(sorted(s))\n4385528064\n</code></pre> <pre><code>&gt;&gt;&gt; our_str ='Bonjour Monde'\n&gt;&gt;&gt; id(our_str)\n4382424112                        &lt;== ok\n&gt;&gt;&gt; our_str = 'Hello World'\n&gt;&gt;&gt; id(our_str)\n4385028914                        &lt;== new string, new id!\n</code></pre> <pre><code>&gt;&gt;&gt; h = 'hello'\n&gt;&gt;&gt; w = 'world'\n&gt;&gt;&gt; h + ' ' + w\n'hello world'\n&gt;&gt;&gt; id(h)\n4382424112\n&gt;&gt;&gt; h = h + ' ' + w\n&gt;&gt;&gt; id(h)\n4384848624\n&gt;&gt;&gt; h\n'hello world'\n</code></pre></p> <p>See also Type</p> Immutable <p>Keys in dictionaries have to be immutable (so can be hashed!) meaning only strings, numbers, frozensets, tuples, bool, range can be dictionary keys</p> Method Resolution Order (MRO) <p>A list of classes. The first is the object at hand, the next ones are the parent classES, followed by the grandparent classES...</p> Mutability <p>The value of some objects can change (an object as a type, value, and identity -- type and identity of the object stays constant!). Objects whose value can change are said to be mutable (list, dict, set can be changed after their creation); objects whose value is unchangeable once they are created are called immutable (e.g. numbers, tuples, strings, frozensets, bools, ranges)</p> <p>See also Container Object</p> Parallelism <p>Parallelism is concerned with utilizing multiple processors/cores to improve the performance of a computation. Beware parallelism and concurrency are distinct concepts. Concurrency is concerned with managing access to shared state from different threads.</p> Reference <p>In Python, a reference is a name that points to an object in memory. When you assign a variable to a value, you're actually assigning a reference to that object, not copying the data itself.  The variables hold references, not values <pre><code>a = [1, 2, 3]          # 'a' holds a reference to the list [1, 2, 3]\nb = a                  # 'b' is another reference to the same list\n\n# Both a and b reference the same list in memory.\n# Modifying one affects the other.\n\nb.append(4)            # Modify the list using the 'b' variable\n\nprint(a)               # [1, 2, 3, 4]\nprint(b)               # [1, 2, 3, 4] (same list)\n</code></pre> <pre><code>a = [1, 2, 3]\nb = a.copy()           # Creates a new list (a shallow copy)\n                       # similar to a[:] ?\n\nb.append(4)            # Modify 'b' only\n\nprint(a)               # [1, 2, 3] (original remains unchanged)\nprint(b)               # [1, 2, 3, 4] (new copy)\n</code></pre> <pre><code>x = [10, 20, 30]\ny = x                  # y references the same object\n\nprint(id(x) == id(y))  # \u2705 True (same object)\n</code></pre> <pre><code>z = x.copy()\nprint(id(x) == id(z))  # \u274c False (different objects) &lt;-- different object because different memory space!\n</code></pre> <pre><code>a = 100\nb = 100\nprint(id(a) == id(b))  # \u2705 True (same reference)\n\nx = \"hello\"\ny = \"hello\"\nprint(id(x) == id(y))  # \u2705 True (Python reuses string literals)\n</code></pre></p> Shallow Copy <p>A shallow copy only duplicates the outer container \u2014 the inner elements are still references to the same objects. In contrast, a deep copy duplicates not just the outer object (like a list), but also all the nested mutable objects inside it.</p> Thread <p>Multiple threads live in the same process in the same space, each thread will do a specific task, have its own code, own stack memory, instruction pointer, and share heap/virtual memory. If a thread has a memory leak it can damage the other threads and parent process. </p> <p>See also Global Interpreter Lock</p> Type <p>Example <pre><code>&gt;&gt;&gt; type((1,2))\n&lt;class 'tuple'&gt;\n&gt;&gt;&gt; type('hello')\n&lt;class 'str'&gt;\n</code></pre></p> <p>See also Identity</p> Value <p>See also Identity and Type</p>"},{"location":"python/#code-primer","title":"Code Primer","text":"Arguments from command line<pre><code>#!/usr/bin/env python3\n\nimport sys\n\ndef main(argv):\n    assert len(argv) &gt;= 3, 'Too few parameters'\n    assert len(argv) &lt;= 1, 'No parameter to command line provided'\n    print(argv)\n\n    prog_name = argv[0]\n    argument_1 = argv[1]\n\n\nif __name__ == \"__main__\":     # when you run the python file, __name__ is set to \"__main__\"\n                               # Otherwise it is set to the module name\n    main(sys.argv)\n</code></pre> The invisible dictionary problem :-)<pre><code>#!/usr/bin/env python3\n\n# Given a list of words, group the anagram in a sublist together\n# ['abc', 'bar', 'cab'] ---&gt; [ ['cab', 'abc'], ['bar']]\n\ndef ana(L):                             # (1)\n    anagrams = {}\n    for word in L:\n        K = ''.join(sorted(word))       # (2)\n        if K not in anagrams.keys():    # (3)\n            anagrams[K] = []\n        anagrams[K].append(word)        # = anagram_list\n    dict_values = anagrams.values()     # &lt;!&gt; type is dict_values([['abc', 'cab'], ['bar']])\n    return( list(dict_values) )         # return the values of the anagrams dict in a list format\n\n# ana(['abc', 'bar', 'cab'])[0]\n# Traceback (most recent call last):\n#   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n# TypeError: 'dict_values' object is not subscriptable\n# list(ana(['abc', 'bar', 'cab']))[0]\n# ['abc', 'cab']\n</code></pre> <ol> <li>L is list of words</li> <li>Reorder the chars of the word     sorted(word) ==&gt; list of ordered characters as if 'word' was a list of char     sorted('akc') ==&gt; ['a', 'c', 'k']</li> <li>K is NOT already a key in the dictionary     ... create key/entry + initialize</li> </ol> Add elements in two lists<pre><code>x_values_list = [1, 2, 3] \ny_values_list = [4, 5, 6] \n\nm = map(lambda x, y: x + y, x_values_list, y_values_list)     # m is &lt;map at 0x104a65180&gt;\n                                                              # similar to: for x, y in zip(x_values_list, y_values_list) ? Almost!\n                                                              # zip returns an iterable on tuples, not a map object!\ntype(m)                                                       # m is a map\nlist(m)                                                       # a list ;-)   or [5, 7, 9]\n\nret_list = list(map(lambda x, y: x + y, x_values_list, y_values_list))   # Add list for Python3\nret_list = list(map(lambda x: x**2, x_values_list))\n</code></pre> Sorting list of tuples uses the first element of the tuple<pre><code>&gt;&gt;&gt; _list = [ ('a',34), ('z', 23), ('b', 44)]\n&gt;&gt;&gt; sorted(_list)                                 # sort list items based on the first value in the \n[('a', 34), ('b', 44), ('z', 23)]\n\n# (DEPRECATED) Sort based on 2nd field of tuple ~~~&gt; reverse tuple\n&gt;&gt;&gt; _list = sorted(list(map(lambda el: el[::-1], _list)))\n\n# &gt;&gt;&gt; el_values_list = _list                                            # Those 2 lines ... \n# &gt;&gt;&gt; _list = sorted(list(map(lambda el: el[::-1], el_values_list)))    # ... do the same as above! \n\n&gt;&gt;&gt; sorted(_list)                              # Sort the elements of a list... using the first value in each element! \n[(23, 'z'), (34, 'a'), (44, 'b')]\n</code></pre> Sorting list of tuples using the 2 element of each tuple<pre><code>data = [(\"apple\", 3), (\"banana\", 1), (\"cherry\", 2)]\n\n# Sort by second element (index 1)\nsorted_data = sorted(data, key=lambda x: x[1])\n\nprint(sorted_data)\n# Output: [('banana', 1), ('cherry', 2), ('apple', 3)]\n</code></pre> List comprehension<pre><code>&gt;&gt;&gt; [ c*2 for c in \"012345678\" ]\n['00', '11', '22', '33', '44', '55', '66', '77', '88']\n\n# Dictionary comprehension\n# build a new dictionary using a function\nmy_dictionary_comprehension = {k: f(v) for k, v in d.items()  if k == 1}\n\n# Fct\ndef myfunc(self, *args, **kwargs) :    # args is a tuple, kwargs is a dict\n</code></pre> Getting help<pre><code>import my_module as mm\nhelp(mm)                     # print the docstring of the module + of functions\nhelp(mm.greet)               # print the docstring of the given function in the module\nhelp(WHATEVER)               # &lt;== prints docstrings\nhelp()                       # &lt;== help in interactive mode\n\nhelp(dir)\ndir()                        # List variables/names in the current scope\ndir(int)                     # dir (&lt;class&gt;) --&gt; list methods of &lt;class&gt;\nhelp(int.to_bytes)           # help ( &lt;class&gt;.&lt;method&gt; )\ndir(WHATEVER)                &lt;== returns a list of variables in scope of methods\n\nassert 3/4 &gt; 1, \"not so fast!\"  # raise AssertionError with explanation\nhelp(assert)                 # Fails, assert is a statement, not a function, i.e. assert()!\nhelp(assert.__doc__)         # Fails \nhelp('assert')               # Works! help for the standalone command 'assert'\n\n\nhelp(str)                    # return info for method and class for 'str' objects\nhelp(str.__doc__)            # ok, works, but not formatted correctly\nprint(str.__doc__)           # print the help for the 'str' type conversion function\n\n&lt;!&gt; If module was already loaded, you need to reload it!\nimport importlib\nimportlib.reload(my_module)  # or .reload(mm)\n</code></pre> Primer with doctests<pre><code># To run if testmod block is not present: python -m doctest your_file.py\n# Python will automatically scan the file for docstring tests and run them.\ndef add(a, b):\n    \"\"\"\n    Returns the sum of a and b.\n\n    &gt;&gt;&gt; add(2, 3)\n    5\n    &gt;&gt;&gt; add(-1, 1)\n    0\n    \"\"\"\n    return a + b\n\n# To run the tests (with testmod() block ): python calculator.py\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n</code></pre> Primer with Python debugger<pre><code>import pdb\n\ndef add(a, b):\n    pdb.set_trace()                               # Execution will pause here (when run with pdb)\n    return a + b\n\nresult = add(3, 5)\nprint(result)\n\n\n\n$ python -m pdb my_script.py                      # run the pdb\n\npdb\n# operations\nn | next\ns | step               - step into a function call\nc | continue           - continue exection until next breakbpoint\nr | return             - continue execution until function returns\nq | quit               - quit debugger\n\nb 10                   - set a breakpoint at line 10\nl | list               - list all breakpoints\n\n\np variable             - print the value of a variable\npp variable            - pretty print of a variable\n</code></pre>"},{"location":"python/#miscellaneous","title":"Miscellaneous","text":""},{"location":"python/#hello-world","title":"Hello world!","text":"<pre><code>$ python3 --version\nPython 3.9.10\n\n$ python3\n&gt;&gt;&gt; print(\"Hello world!\")             # Python 3\n&gt;&gt;&gt; 2+1\n&gt;&gt;&gt; 2*(3+4)\n#!/usr/bin/env python\n#!/usr/bin/env python2      # DEPRECATED\n#!/usr/bin/env python3\n</code></pre>"},{"location":"python/#data-structure-algorithm","title":"Data structure &amp; algorithm","text":"<p>Set ::</p> <p>List ::</p> <p>Map ::</p> <p>Trees ::</p> <p>Graph ::</p> <p>Big0 notiation ::</p>"},{"location":"python/#check-this-site","title":"Check this site","text":"<ul> <li> <p>https://csvistool.com/</p> </li> <li> <p>https://csvistool.com/</p> </li> <li> <p>https://csvistool.com/</p> </li> </ul>"},{"location":"python/#variables-scopes","title":"Variables scopes","text":""},{"location":"python/#global-variables","title":"Global variables","text":"<pre><code>globvar = 0\n\ndef set_globvar_to_one():\n    global globvar    # Needed to modify global copy of globvar\n    globvar = 1\n\ndef print_globvar():\n    print(globvar)     # No need for global declaration to read value of globvar\n\nset_globvar_to_one()\nprint_globvar()       # Prints 1\n</code></pre>"},{"location":"python/#name","title":"name","text":"<pre><code># mymodule.py\nprint(f\"__name__ is: {__name__}\")\n</code></pre> <pre><code># main.py\nimport module          # Outputs __name__ is: mymodule\n</code></pre>"},{"location":"python/#numbers","title":"Numbers","text":"<p>Numbers are immutable!</p> <p>so are strings, tuples, etc.</p> <p>But beware: it is the content that is immutable, the variable that points to this content can still change!</p> <pre><code>0\n1\n1.2\n34.56\n-56.3\n\n&gt;&gt;&gt; a = 1\n&gt;&gt;&gt; id(1)\n4329177328\n&gt;&gt;&gt; id(a)\n4329177328\n\n&gt;&gt;&gt; a = 256                               # Variable is pointing to the identity of another immutable number!\n&gt;&gt;&gt; id(256)                               # If you take a higher number, the id can change !!!!\n4329185488\n&gt;&gt;&gt; id(a)\n4329185488\n</code></pre> <p>More About (im)mutability @ https://towardsdatascience.com/https-towardsdatascience-com-python-basics-mutable-vs-immutable-objects-829a0cb1530a</p>"},{"location":"python/#integer-and-float","title":"integer and float","text":"<pre><code>5 / 2 == 2.5                        # Python 3 only !\n5 // 2 == 2                         # Python 3 only (equivalent to floor) !\nmath.floor(5/2)        # rounds down towards -oo --&gt; outputs 2\nmath.floor(-5/2)       # Outputs -3     \nmath.ceil(5/2)         # rounds up towards +oo --&gt; Outputs 3\nmath.ceil(-5/2)        # rounds up towards +oo --&gt; Outputs -2 \nround(5/2)        # rounds towards 0? NO, round half (.5) to closest even --&gt; Outputs 2 (rounds down)\nround(-5/2)       # Outputs -2  &lt;-- round is symetric and round up and down (to avoid bias)\nround(7/2)        # Outputs 4 (rounds up!)\nround(-7/2)       # Outputs -4\nint(3.7)          # outputs 3  &lt;-- always round towards 0!\nint(-3.7)         # outputs -3\nmath.trunc(3.7)   # equivalent to int(3.7)\n\n# Function Returning Multiple Values (Tuple)\ndef divide(a: int, b: int) -&gt; tuple[int, int]:   # Takes two integers, returns a tuple of int\n    return a // b, a % b                         # // and % work together!\n\n\nimport math\n&gt;&gt;&gt; _pi = math.pi\n&gt;&gt;&gt; print(_pi)\n3.141592653589793\n\n&gt;&gt;&gt; g1 = round(_pi,2)                 # Rounding floats\n&gt;&gt;&gt; print(g1)\n3.14\n\n\n&gt;&gt;&gt; g2 = float(\"{1:.2f}\".format(0.1234, _pi))   # Same operation with conversion through a formatted string!\n                                        # float --&gt; turn string into float\n                                        # format string with element 1 in format (which is _pi!)\n                                        # and format it with .2f as a float with 2 digits after the comma\n&gt;&gt;&gt; g\n3.14\n</code></pre> <p>Source @ http://www.tutorialspoint.com/python/python_basic_operators.htm</p>"},{"location":"python/#bitwise-operation","title":"bitwise operation","text":"<p>&lt;!&gt; Spaces added in binary value for clarity but must be removed in real python code&lt;&gt;  &lt;!&gt; Prefix 'b' as in b\"0001\" ==&gt; bytes, prefix '0b' as in 0b0001 ==&gt; integer_coded_in_binary</p> <pre><code>a = 0b 0011 1100                  # a = 60 !\nb = 0b 0000 1101                  # b = 13 !\n-----------------\n\na&amp;b = 0b 0000 1100                 @ a AND B\n\na|b = 0b 0011 1101                 # a OR B\n\na^b = 0b 0011 0001                 # a XOR b\n                                   # Note that 2^2 is not 2**2 !!\n\n~a  = 0b 1100 0011                 # NOT a\n</code></pre> <p>Source @ http://www.tutorialspoint.com/python/python_basic_operators.htm</p>"},{"location":"python/#byte","title":"byte","text":"<pre><code>two_bytes = b'\\x01\\x02'\nnumber = int.from_bytes(two_bytes, byteorder='big')      # Interprets as 258 (1*256 + 2)\nprint(number)\n\nnumber = 258\nbytes_obj = number.to_bytes(2, 'big')  # Outputs: b'\\x01\\x02'\nprint(bytes_obj)\n</code></pre> <pre><code>byte1 = b'\\x05'\nbyte2 = b'\\x03'\n\n# Extract the integer values (5 and 3)\nvalue1 = byte1[0]\nvalue2 = byte2[0]\n\n# Perform arithmetic addition\nsum_value = value1 + value2  # 5 + 3 = 8\nprint(sum_value)  # Outputs: 8\n\n# Optionally, convert the result back to a bytes object (if it fits in one byte)\nresult_byte = sum_value.to_bytes(1, 'big')\nprint(result_byte)  # Outputs: b'\\x08'\n</code></pre>"},{"location":"python/#introspection","title":"introspection","text":"<pre><code>&gt;&gt;&gt; i = 17\n&gt;&gt;&gt; type(i)\n&lt;class 'int'&gt;\n\n&gt;&gt;&gt; dir(45)\n['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'real', 'to_bytes']\n\n&gt;&gt;&gt; help(int.to_bytes)\n... shows method descriptor ...\n\n&gt;&gt;&gt; i.to_bytes(2,\"big\")        # 2-byte representation\n                               # 'big', the most significant byte is at the beginning of the byte array.\nb'\\x00\\x11'\n\n&gt;&gt;&gt; i.to_bytes(4,\"big\")\nb'\\x00\\x00\\x00\\x11'\n&gt;&gt;&gt; i.to_bytes(4,\"little\")\nb'\\x11\\x00\\x00\\x00'\n</code></pre>"},{"location":"python/#strings","title":"Strings","text":""},{"location":"python/#immutability","title":"Immutability","text":"<p>A string ~= immutable tuple of characters</p> <p>In Python, immutability refers to the property of an object that cannot be changed after it is created.</p> <pre><code>\"hello\" ~= ('h', 'e', 'l', 'l', 'o' )\n</code></pre> <p>Well, not exactly because their types are different, one is 'str' while the other is 'tuple'. They are also different objects, with different methods!</p> <pre><code>type('hello')                       # &lt;class 'str'&gt;\ntype(('h', 'e', 'l', 'l', 'o'))     # &lt;class 'tuple'&gt;\n</code></pre> <ul> <li>Strings are immutable in python (see replace) as are number (int, float, decimal), bool,  tuple, and range!</li> <li>What is immutable is the content of the string, the variable can be reassigned!</li> </ul> <p>What is unicode and utf-8 @ https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/</p> <p>Demonstration of immutability</p> <p><pre><code>&gt;&gt;&gt; text = \"Data Science\"\n&gt;&gt;&gt; print(id(text))\n2450343168944                            # also = to id(\"Data Science\") ;-)\n\n&gt;&gt;&gt; text += \" with Python\"\n&gt;&gt;&gt; print(id(text))\n2450343426208                            # The variable points to a new identity (~pointer)\n</code></pre> Source @ https://towardsdatascience.com/https-towardsdatascience-com-python-basics-mutable-vs-immutable-objects-829a0cb1530a</p> <pre><code>our_str ='Bonjour Monde'\nour_str = 'Hello World'                         # Override variable &lt;&gt; immutability of pointed content\n\nprint(our_str[0])                               # At a given index, you can read, but you cannot write!\n# our_str[0] = 'h'                              # Exception: TypeError: 'str' object does not support item assignment\n# our_str[0] = our_str[0].lower()               # Exception! Strings are immutable\nnew_str = our_str.replace('World', 'Jackson')   # HERE we create a new string, the old string is not changed!\n</code></pre>"},{"location":"python/#hands-on","title":"Hands-on","text":"<pre><code># &lt;!&gt; sorted(string) return a sorted list of characters contained in string\n# &lt;!&gt; This list needs to be turned into a string using join()!\nordered_chars_LIST = sorted(string_of_unordered_chars)       # returns an ordered LIST or characters , not a string but a LIST!\nordered_chars = ''.join(sorted(unordered_chars))   # Order a string (anagram)\n\n\nstring1 = \"this is a string\"\nstring2 = \"%s! %s\" % (\"hello\",\"toto\")                             # Print a string in a string!\nstring3 = \"%(h)s! %(n)s\" % { \"n\":\"toto\", \"h\":\"hello\"}             # Using named variable from a dictionary (great for templating!)\n\nstring4 = \"a number y is {1:.2f} and x is {0:.3f}\".format(x, y)   # order from tuple followed by format!\n\nprice = 4.55\nstring5 = f\"Price in Swiss Franks: {price * 1.086:5.2f}\"          # String literal &lt;!&gt; 'price' variable must exists\n                                                                  # Don't forget the 'f' at the beginning of the string!\n\nstr(3210)                                  # Convert number to string '3210'\nstr(\"hello\")                               # Convert a string into a string, i.e. do nothing!\n\nfloat(\"3.1415\")                            # Turn a string to float\nint(\"3\")                                   # Turn a string to a integer\n# int(\"3.1415\")                            # &lt;!&gt; This is an error as this is a float\nint(float(\"3.14\"))                         # &lt;!&gt; Ok, this works! ;-) and is 3\n\nstring3 = string1 + string2                # Concatenation operation\nmultiline = \"This is a \\n\\\n... multiline string\"                      # Multiline string\n#comment\nlen(var3)                                  # Length of a string\n\n\nprint(program, \"arguments\")                # Python3\nprint(program, \"arguments\", sep=\" \", end=\"\\n\")    # Python3 equivalent = Concat 2 strings with a space in between + CR at the end\n\n\n&gt;&gt;&gt; list(\"hello world\")                    # A string = tuple of chars --&gt; turn a tuple of char into a list!\n['h', 'e', ...., 'o', ' ', 'w', ..., 'd']\n\n# &lt;!&gt; Strings are immutable, but here you are just changing where the variable points to, not the string\ns = s.lstrip()                             # Remove leading spaces\ns = s.rstrip()                             # Remove trailing spaces and CARRIAGE RETURNS\ns = s.strip()                              # Remove leading and trailing spaces and CARRIAGE RETURNS\n\ntitle = title.strip(',.-\\n')               # Remove leading and trailing characters\n                                           # &lt;!&gt; Will strip any of those characters, not the string \",.-\" but individual characters!\n\nnumber_of_ts = s.count('t')                # Return number of character 't' in the string\nnumber_of_totos = s.count('toto')          # Return number of substrings\n\npos_of_first_t = s.find('t')\npos_of_second_t = s.find('t', pos_of_first_t)     # Find returns the index of first found 't' (or second t since starting from 1st 't' position)\n                                                  # If find reaches the end, then returns -1\n\ns.capitalize()\ns.join()\ns.split()                    # Split on any-block of spaces/tabs\n                             # , e.g. \"12    3 4\" --&gt; ['12', '3', '4']\n# s.split('')                # &lt;!&gt; but this ~~~&gt; ValueError: empty separator!\n# s.split(\"\")                # &lt;!&gt; but this ~~~&gt; ValueError: empty separator!\ns.split(\"\\t\")                # split on tab characters (\\t is the tab character, not 2 chars!)\ns.split(\" \")                 # split on space charactes only, not tabs!\n\"hello world\".split(\"wo\")    # split on a GROUP of characters &lt;!&gt; Not like strip, which assume individual characters\n\"arn::account::region\".split(\"::\")    # returns a list!\n\n# Replace = split and join?\narn = \"arn::account::region\"\narn = \"XX\".join(arn.split(\"::\"))\n=?= arn.replace(\"::\",\"XX\")            # ?\n\n&gt;&gt;&gt; s.translate(None, \",!.;\")          # Remove unwanted characters, here the punctuation\n\n&gt;&gt;&gt; \"Python\".center(10)\n'  Python  '\n\ns.endswith('toto')\ns.startswith('toto')\n\ns = \"one\\ttwo\\t\\tthree\\nfout\"      # Tabs and other special characters in a string\nprint(s)                           # Transform tabs and other special characters\n\nstring_content = \"line 1\\nline 2\\nline 3\\n\"\nstring_file_content.splitlines()             # ~ s.split('\\n') ?\n[ 'line 1', 'line 2', 'line 3']\n\n&gt;&gt;&gt; account_number = \"43447879\"\n&gt;&gt;&gt; account_number.zfill(12)             # Zero fill\n'000043447879'\n&gt;&gt;&gt; account_number.rjust(12,\"0\")         # Right justification\n'000043447879'\n\n                                         # &lt;!&gt; Immutability: can only be read\nstring[0]                                # first character\nstring[-1]                               # very last character\nstring[1:4]                              # a slice\nstring[10:]                              # a slice to end of string\nstring[:-1]                              # everything but last character\nstring[:]                             # copy of string\nstring[::1]                           # copy of string, step of 1 (default)\nstring[::2]                           # print every other characters!\nstring[::-1]                          # reverse string, step of -1\n\nstring[::-2]                          # reverse string + take every other characters\n\ns = \" a very long string ..... \"         # pep8 compliance for long string\ns =(\n  \"a very long\"\n  \"string ... \"\n)\n\ns = \"\"\"\n    A multi-line string\n    With space as well\nand carriage returns\n\"\"\"\n\ns                      # '\\n    A multi-line string\\n    With space as well\\nand carriage returns\\n'\n\nprint(s)                # \n                        #   A multi-line string\n                        #   With space as well\n                        # and carriage returns\n</code></pre>"},{"location":"python/#operations","title":"Operations","text":"<pre><code>print(\"12\" + \"34\")      # Outputs: \"1234\"\nprint(\"12\" * 2)         # Outputs: \"1212\"\n</code></pre> <p>Equality/Inequality used for sorting list of strings with sorted!</p> <pre><code>(\"a\" &lt; \"b\")   is True   # True\n(\"a\" &lt; \"aaa\") is True   # True\n(\"1\" &lt; \"a\")   is True   # True\n(\"aaa\" &lt; \"a\") is False  # True, it is False ;-)\n\n# Sorting based on ASCII code of characters!\nout = sorted([\"aaa\", \"b\", \"a\", \"2\", \"-1\", \"0\"])\nprint(out)              # Outputs: [\"-1\", \"0\", \"2\", \"a\", \"aaa\", \"b\"]\n#\n</code></pre>"},{"location":"python/#print-format-and-string-literal","title":"Print, format, and string literal","text":"<p> % is an operation on string!</p> <p><pre><code>print(word)\nprint(word, end='\\n')                # Same as above (default)\nprint(word, end='')                  # Print without \\n\n\nprint(pyObject)                      # Use the __str__ method or if missing the __repr__ method\nprint(\"%s\" % pyObject)               # Use the __str__ method or if missing the __repr__ method as well and ...\n                                     # ... the module operator of string class!)\n                                     # &lt;!&gt; __repr__ method is used for representation of the object in ipython when '&gt;&gt;&gt; object'\n\nprint(word.__repr__())               # Print single quoted string as word.__repr__() is \"'hello'\"\nprint(str(pyObject))                 # Convert using the __str__ method\n                                     # &lt;-- this is the correct one!\n\nprint('a very very '\n'very vreey '\n'very long ine'\n)\n</code></pre> <pre><code>s = 'hello world!'\npi = 3.1415\nprint(f's is {s} and pi is {pi:.2}')          # String literal\n                                              # &lt;!&gt;  do not forget the 'f' before the quote otherwise not expended!\nprint(f's is {s} and pi is {pi:.2f}')         # &lt;!&gt; also do not forget the f in the formatting of pi to indicate a float\n                                              # the first line prints 3.1 and the second 3.14 for the value of pi !!!\n</code></pre> <pre><code>&gt;&gt;&gt; print(q, p, p * q, sep= \" \", end=\"\\n\")      # (default) sep -&gt; separator     end -&gt; CR\n&gt;&gt;&gt; print(q, p, p * q, sep=\" :-) \", end=\"\")     # sep -&gt; separator     end -&gt; no carriage return\n459 :-) 0.098 :-) 44.982\n</code></pre></p> <p>FORMAT</p> <p> The pythonic way to print strings, because strings are objects!</p> <pre><code>&gt;&gt;&gt; print(\"average is {f}\".format(average, f=1))     # here f is a MIX of variables + named arguments\naverage is 1                                         # &lt;!&gt; 1 is not the DEFAULT value for f, but the constant value of f !\n                                                     # f is a keyword argument (a variable to be called in the formatted string)\n\n&gt;&gt;&gt; print(\"average is {:f}\".format(average, f=1))    # here f is formatting of DEFAULT first element, i.e 0, as a float\n                                                     # &lt;!&gt; if {} were to reappear in the string, it would point to the second element (which does not exist here)\n                                                     # {} points to the first element only when appear first, then the counter is incremented!\naverage is 2.300000\n&gt;&gt;&gt; print(\"average is {0:f}\".format(average, f=1))    # here f is formatting of element 0 (float) - same as above but more explicit!\naverage is 2.300000\n&gt;&gt;&gt; &gt;&gt;&gt; print(\"average is {1:f}\".format(average, 3.4, f=1.2))    # here 3.4 is element at pos 1\naverage is 3.400000                                              # Is f=1.2 at pos 2? NO! 'f' = keyword argument (**kwargs), while average and 3.4 are positional args (*args)\n\n# &gt;&gt;&gt; print(\"average is {1:f}\".format(average, f=1))    # IndexError: Replacement index 1 out of range for positional args tuple\n                                                        # Tuple *arg vs **kargs dict ? Yes!\n\n&gt;&gt;&gt; f = 1\n&gt;&gt;&gt; print(\"average is {1:f} {0:f}\".format(average, f))  # the last f is the value of the variable 'f' and is a positional argument of the format method\n\n\n&gt;&gt;&gt; x = 3.1415\n&gt;&gt;&gt; float(\"{0:.2f}\".format(x))                 # don't forget the 'f' for float!\n3.14\n\n&gt;&gt;&gt; print(\"{:d}\".format(7000))\n7000\n&gt;&gt;&gt; print(\"{:,d}\".format(7000))\n7,000\n&gt;&gt;&gt; print(\"{:^15,d}\".format(7000))              # 15 is total number of characters, 7,0000 is centered\n     7,000\n&gt;&gt;&gt; print(\"{:*^15,d}\".format(7000))\n*****7,000*****\n&gt;&gt;&gt; print(\"{:*^15.2f}\".format(7000))\n****7000.00****\n&gt;&gt;&gt; print(\"{:*&gt;15,d}\".format(7000))\n**********7,000\n&gt;&gt;&gt; print(\"{:*&lt;15,d}\".format(7000))             # left alignment\n7,000**********\n&gt;&gt;&gt; print(\"{:*&gt;15X}\".format(7000))              # right alignment\n***********1B58\n&gt;&gt;&gt; print(\"{:*&lt;#15x}\".format(7000))             # hexadecimal format\n0x1b58*********\n\n\nif not testbed:\n        raise Exception(\"No such testbed {}\".format(testbed_name))\n\n&gt;&gt;&gt; '{0}{1}{0}'.format('abra', 'cad')                  # arguments' indices can be repeated\n'abracadabra'                                          # ~ format of a tuple, and index in the tuple\n\n&gt;&gt;&gt; 'Coordinates: {latitude}, {longitude}'.format(latitude='37.24N', longitude='-115.81W')  # With named arguments\n'Coordinates: 37.24N, -115.81W'\n&gt;&gt;&gt; \"Art: {a:5d},  Price: {p:8.2f}\".format(a=453, p=59.058)\n'Art:   453,  Price:    59.06'\n\n&gt;&gt;&gt; print(\"I've &lt;{}&gt; years of experience and my salary is &lt;{:,}&gt; USD per annum.\".format(10, 75000))  # {} points to first and then {} points to second element\nI've &lt;10&gt; years of experience and my salary is &lt;75,000&gt; USD per annum.\n\n&gt;&gt;&gt; data = dict(province=\"Ontario\",capital=\"Toronto\")\n&gt;&gt;&gt; data\n{'province': 'Ontario', 'capital': 'Toronto'}\n&gt;&gt;&gt; print(\"The capital of {province} is {capital}\".format(**data))         # With a dictionary\n                                                                           # SWEET **kwargs --&gt; **dictionary !!!\n\n\"{0:&lt;20s} {1:6.2f}\".format('Spam &amp; Eggs:', 6.99)                           # With anchored strings\n'Spam &amp; Eggs:           6.99'\n\n\n&gt;&gt;&gt; class Point(object):\n...     def __init__(self, x, y):\n...         self.x, self.y = x, y\n...     def __str__(self):\n...         return 'Point({self.x}, {self.y})'.format(self=self)          # with objects\n...     def __repr__(self):\n...             return 'REPR Point({self.x}, {self.y})'.format(self=self)\n...\n&gt;&gt;&gt; str(Point(4, 2))\n'Point(4, 2)'\n&gt;&gt;&gt; Point(4,2)\nREPR Point(4, 2)\n</code></pre> <p>Source @ https://www.python-course.eu/python3_formatted_output.php</p> <p>More @ https://www.techbeamers.com/python-format-string-list-dict/</p> <p>SHORT FORMAT (aka string literal -- see above)   * &lt;!&gt; If variable does not exist ---&gt; Exception: !NameError: name 'ss' is not defined</p> <pre><code>def greet(name):\n    print(f\"Hello {name}\")           # aka string literal\n</code></pre>"},{"location":"python/#print-in-a-file","title":"Print in a file","text":"<pre><code>from __future__ import print_function\n\ns = 'hello world!'\n# f = open(\"file.txt\", \"a\")\nwith open(\"file.txt\", \"a\") as f:\n    print(s, end=\"\", file=f)            # Python3\n</code></pre> <p>Source @ https://stackoverflow.com/questions/9236198/python-3-operator-to-print-to-file</p>"},{"location":"python/#conversion","title":"Conversion","text":"<ul> <li> List are indexed at 0</li> <li> spliting a list gives you a list of string which you need to reformat </li> </ul> <pre><code>abc = \"abcde....z\"        # A string is an immutable tuple of characters\nchar_list = list(abc)\n\n\ns = 'afdadf 5 dfad 5.0 dfdsdf'\n# token = s.split(' ')          # Split on space character\ntoken = s.split()               # Split on any space char, including tab and multiple space\nsum = sum + int(token[1]) + float(token[3])   # sum = sum + 5 + 5.0\n</code></pre>"},{"location":"python/#char-in-strings-char-string-of-len-1","title":"Char in strings (char = string of len 1)","text":"<p>Char is a string of length 1 !</p> <pre><code>abc = \"abcde....z\"          # sring = an immutalbe tuple of characters!\nchar_list = list(abc)\n\n&gt;&gt;&gt; type('a')\n&lt;class 'str'&gt;\n&gt;&gt;&gt; chr(97)\n'a'\n&gt;&gt;&gt; ord('a')              # works only on string of length 1\n97\n\ntype(chr(97))             # &lt;class 'str'&gt;\n\n&gt;&gt;&gt; s = \"asjo,fdjk;djaso,oio!kod.kps\"\n&gt;&gt;&gt; s.translate(None, \",!.;\")          # Remove unwanted characters\n'asjofdjkdjasooiokodkjodsdkps'\n\nlist('cat')                            # Turn a list in list of chars\n['c', 'a',''t' ]\n\n\n&gt;&gt;&gt; for char in \"python\":              # iterate on the char\n...     print(char)\n\n&gt;&gt;&gt; for char in list(string):    # string --&gt; list of chars (same as above)\n    print(char)\n\nfor pos, char in enumerate(string):         # With index/position!\n    print(pos, char)\n    print(pos, char, sep=' ', end='\\n')     # same as above (with explicit default values!)\n</code></pre>"},{"location":"python/#words-in-string-not-regex","title":"Words in string (not regex)","text":"<p> Instead of regex, use method or operations of strings</p> <pre><code>new_str = our_str.replace('World', 'Jackson')    # Don't change the same string\n                                                 # &lt;!&gt; strings are immutable!\n\nif \"blah\" in \"otherstringblahtoto\": \n    print('found group of chars')\n\ns = 'tatatititata'\nif s.find('toto') == -1:\n    print(\"Not found!\")\n\ns.find('ata')                  # return the position of the first occurence\n\n\ns = \"worl\"\nS = \"Hello world!\"\n&gt;&gt;&gt; S.find(s)\n7\n\ns.endswith('toto')\ns.startswith('toto')\n\nwith open(\"myfile\", r) as file:\n\n    # for line in file.readlines():\n    for line in file:                               # readlines from files (.readlines is implied)\n        # print(line)\n        # print(line, end='\\n')                     # Same as line above, but &lt;!&gt; the line also includes a carriage return! ==&gt; 2 carriage returns!\n        print(line, end='')                         # Here we remove the extra carriage return added by the print statement!\n        print(line.rstrip())                        # Here we remove the \\n from the string, but add the one from the print!\n\nfor word in string.split():                         # Process words one at a time (split on spaces)\n    print(word, end='')                             # (Python3)\n</code></pre> <p>REGEX overkill!</p> <pre><code># Using regex module!\nimport re\nwords = re.split('\\W+', 'Words1, words2, words3.')   # \\W+ matches **one or more non-word characters**\nprint(words)               # Outputs ['Words', 'words', 'words', '']\n</code></pre>"},{"location":"python/#str-method-of-classesobjects","title":"Str method of Classes/Objects","text":"<pre><code>&gt;&gt;&gt; class Point(object):\n...     def __init__(self, x, y):\n...         self.x, self.y = x, y\n...     def __str__(self):\n...         \"\"\"Used for string conversion, i.e. str(point) or print(point) or '%s' % point \"\"\"\n...         return 'Point({self.x}, {self.y})'.format(self=self)\n...     def __repr__(self):\n...         \"\"\"Used for repr(point) or in ipython when &gt;&gt;&gt; P\n...            but is also used whenever the __str__() method would normally be used and when not defined/present!\"\"\"\n...         return('toto')\n...\n&gt;&gt;&gt; str(Point(4, 2))\n'Point(4, 2)'\n</code></pre> <p>More @ https://docs.python.org/2/library/string.html</p>"},{"location":"python/#variables-slicing","title":"variables, slicing","text":"<pre><code>2/ STRING, VARIABLES, SLICING\n\n#!/usr/bin/env python\n\nword = input(\"Enter a word: \")                          # python 3\nprint(word[1:] + word[0] + 'ay')\n</code></pre>"},{"location":"python/#user-input","title":"user input","text":"<pre><code>language = input('Enter language')              # Python3 \nif language in ['C++', 'Python', 'Java']:\n   print(language, \"rocks!\")\nif language not in [ 'French', 'English']:\n   print(language, \"sucks!\")\n</code></pre>"},{"location":"python/#introspection_1","title":"Introspection","text":"<ul> <li>&lt;!&gt; used a variable 's' or the type 'str', but not the value of the variable i.e. not 'dir('toto'.replace)</li> </ul> <pre><code>&gt;&gt;&gt; s = 'toto'\n\n&gt;&gt;&gt; type(s)\nstr\n\n&gt;&gt;&gt; dir(s)\n['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']\n\n&gt;&gt;&gt; help(s.split)\nsplit(sep=None, maxsplit=-1) method of builtins.str instance\n...\n</code></pre>"},{"location":"python/#tuple","title":"Tuple","text":""},{"location":"python/#immutability_1","title":"Immutability","text":"<p>Some objects contain references to other objects, these objects are called containers. Some examples of containers are a tuple, list, and dictionary. The value of an immutable container that contains a reference to a mutable object can be changed if that mutable object is changed. &lt;&gt;. <p>Immutability</p> <ul> <li>&lt;!&gt; What is immutable is the content of the tuple, the variable can be reassigned!</li> <li>&lt;!&gt; other immutable types are int, float, decimal, bool, string, tuple, and range.</li> </ul> <p>More @ https://www.thegeekstuff.com/2019/03/python-tuple-examples/#more-17801</p> <ul> <li>&lt;!&gt; TUPLES ARE IMMUTABLE (Value cannot be changed) as are string and numbers</li> <li>&lt;!&gt; TUPLES ARE CONTAINER OBJECT, ex tuple of list</li> </ul> <p>Example</p> <pre><code>t = ([1,2], [0])\nid(t[0])                  # identity of t[0] is 4368558656\nt[0].append(3)            # Here we are not changing the tuple t[0] reference! We are changing the value of the list t[0] is pointing to!\nprint(t)                  # ([1, 2, 3], [0])     &lt;== Value of list in t[0] has changed!\nid(t[0])                  # identity of t[0] is 4368558656   &lt;== id has NOT changed!\n</code></pre> <p>But</p> <pre><code>&gt;&gt;&gt; t[0] = 1                 # t[0] can only point to the particular list it was initialized to!\nTypeError: 'tuple' object does not support item assignment\n</code></pre>"},{"location":"python/#hands-on_1","title":"Hands-on","text":"<p><pre><code>tuple = ([0,1,2], 'two', 'three')\ntuple = [0,1,2], 'two', 'three'       # Same as above without the parentheses!\ntuple                                 # ([0, 1, 2], 'two', 'three')\n\nid(tuple)                       # 4368483584  &lt;-- identity the variable points to\n\ntuple[::-1]                        # reverse a tuple! But immutability?!?!?\n                                   # The identities have not changed in the original tuple!\n('three', 'two', [0, 1, 2])        # Here we are just printing/displaying a new tuple!\n\ntuple = tuple[::-1]            # Now the variable points to a new immutable tuple\nid(tuple)                      # 4364976768 or different from the previous one!\n\n&gt;&gt;&gt; print(tuple[1])\n\n&gt;&gt;&gt; tuple[1] = 'deux'              # BEWARE IMMUTABILITY !\n                                   # Value cannot change! (Assignment)\nTypeError: 'tuple' object does not support item assignment\n\n&gt;&gt;&gt; tuple = ('three', 'two', [0, 'w', 2])\n&gt;&gt;&gt; tuple\n('three', 'two', [0, 'w', 2])\n&gt;&gt;&gt; tuple[2][1] = 'w'              # Here you change the mutable type (list) in the tuple\n                                   # , but the identity (~pointer) as seen by the tuple is still the same!\n\n&gt;&gt;&gt; tuple[1][1] = 'deux'           # Fails because string are immutable, so the id(.) would have to change\n&gt;&gt;&gt; tuple[2][1] = 'y'              # Works because the id in the list changes, but the id seen by the tuple, doesn't\n\n&gt;&gt;&gt; for el in tuple:               # This is what cannot change, the ids(~pointer) in the tuple!\n    ...:     print(id(el))\n    ...:\n140640316455304\n140640317363736\n140640317362392\n</code></pre> <pre><code>nested_tuple = (1,2), (3, 4)           # A tuple of tuple\nnested_tuple[1][1]                     # 4\nnested_tuple                           # ((1, 2), (3, 4))\n\n\n\n!!! Tuples are seen in function\ndef myfunc(self, *args, **kwargs) :    # args is a tuple, kwargs is a dict\n                                       # args = arguments\n                                       # kwargs = keyword_arguments\n</code></pre></p>"},{"location":"python/#zip","title":"zip","text":"<p><pre><code>#!/usr/bin/env python\n\nnames = [\"Alice\", \"Bob\", \"Charlie\", \"Emmanuel\"]\nages = [25, 30, 35]\n\n# Using zip\nzipped = zip(names, ages)            # When the iterables passed to zip() are of unequal length, it stops when the shortest iterable is exhausted.\n\n# Converting to a list to see the output\nprint(list(zipped))\n\n# [('Alice', 25), ('Bob', 30), ('Charlie', 35)]\n</code></pre> <pre><code>#!/usr/bin/env python \n\nnames = [\"Alice\", \"Bob\", \"Charlie\", \"Emmanuel\"]\nages = [25, 30, 35]\n\nfor name, age in zip(names, ages):\n    print(f\"{name} is {age} years old.\")\n\n# Alice is 25 years old.\n# Bob is 30 years old.\n# Charlie is 35 years old.\n</code></pre></p> <pre><code># Zip vs map\n# Zip is more readable\n# map() stops at the shortest iterable, just like ip()\n# map() version is slightly slower and more awkward!\na = [1, 2, 3]\nb = ['a', 'b', 'c']\n\nz1 = list(zip(a, b))\nz2 = list(map(lambda *args: args, a, b))\n\nprint(z1)  # [(1, 'a'), (2, 'b'), (3, 'c')]\nprint(z2)  # [(1, 'a'), (2, 'b'), (3, 'c')]\n</code></pre>"},{"location":"python/#introspection_2","title":"Introspection","text":"<pre><code>&gt;&gt;&gt; t = (1,2)\n\n&gt;&gt;&gt; type(t)\ntuple\n\n&gt;&gt;&gt; dir(t)\n['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'index']\n\n&gt;&gt;&gt; help(t.index)\n\nnestedtuple.index((3,4))            # Where the element can be found &lt;!&gt; only first level element!\n1\n</code></pre>"},{"location":"python/#list","title":"List","text":"<p>Indexed to 0</p> <ul> <li>Lists are indexed to 0</li> <li>First element in the list is at index 0 !!!</li> </ul>"},{"location":"python/#hands-on_2","title":"Hands-on","text":"<p>How do you copy a list?</p> <p>You do NOT copy a list with 'list_0 = list_1', but with  'list0 = list1[:]' for shallow copies and </p> <pre><code>import copy\n\nlst = [[1, 2], [3, 4]]       # A list of mutable elements!\ndeep = copy.deepcopy(lst)    # An entirely different copy\n</code></pre> <p><pre><code>list_0 = [0,1]\nlist_0 = list(range(10))        # Python3: range is an iterator-like, but not an iterator!\nid(list_0)                      # ex: 4368873792\n\nlist_1 = list_0                 # Here you have 2 variables thet refers to the same list object, not a copy!  &lt;-- variables points to the same identity\nid(list_1)                      # ex: 4368873792\n\n\nlist_1[2] = 'X'                 # Changing one will change the other!\nlist_0                          # [0, 1, 'X', 3, 4, 5, 6, 7, 8, 9]\n\nlist_1 = list_0[:]              # This is how to copy a list!     &lt;-- 2 different identities!\nlist_1[3] = 'Y'                 # Will NOT change what list_0 is pointing to! If you change one, you do NOT change the other!\nlist_1                          # [0, 1, 'X', 'Y', 4, 5, 6, 7, 8, 9]\n\nlist_0                          # [0, 1, 'X', 3, 4, 5, 6, 7, 8, 9]\n</code></pre> <pre><code>a = range(10)                       # range(0,10) or 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\na\nb = range(1,11)                     # range(1, 11) or 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\nb\nc = range(30,20,-1)                 # range(30, 20, -1) or 30, 29, 28, ..., 22, 21\nc\n\n\n&gt;&gt;&gt; square=[i**2 for i in a]            # List comprehension\n&gt;&gt;&gt; square=[i**2 for i in range(10)]\n\n[\"Even\" if x % 2 == 0 else \"Odd\" for x in range(5)]    # ['Even', 'Odd', 'Even', 'Odd', 'Even']\n\n\n\u2705 More Readable: Less boilerplate than loops.\n\u2705 Faster: Optimized for performance compared to for loops.\n\u2705 Memory Efficient: Combined with generators, it can reduce memory usage. (generators create values as they are read instead of first and then reading them from memory (as with regular lists)\n</code></pre></p> <p>. &lt;!&gt; &lt;&gt; <p><pre><code>&gt;&gt;&gt; l1 = [1, 2]\n&gt;&gt;&gt; l2 = [3, 4]\n&gt;&gt;&gt; l2 == l2[:] == l2[::]           # Same\nTrue\n&gt;&gt;&gt; l1.extend(l2)                   # Concat the 2 lists and modify one of them in-place ! Here, l1 will be modified!\n                                    # Same as list_1 += list_2 !!   &lt;-- also list_1 keep the same id !!!\n&gt;&gt;&gt; l1\n[1, 2, 3, 4]\n&gt;&gt;&gt; l1.append(l2)                   # Append 1 element at the end of the list (l1 is modified)\n&gt;&gt;&gt; l1\n[1, 2, 3, 4, [3, 4]]\n\n&gt;&gt;&gt; l1.insert(0,\"Yes\")              # In-place insert at the beginning of the list ~ pre-pend!\n                                    # The opposite of append!\n&gt;&gt;&gt; l1[0]\nYes\n&gt;&gt;&gt; l1                              # Note that insert does NOT replace! (unlike l[0] = 'No' would!)\n['Yes', 1, 2, 3, 4, [3, 4]]]\n\n&gt;&gt;&gt; a = 5\n&gt;&gt;&gt; l3 = [1, 2, 3]\n&gt;&gt;&gt; [a] + l3                        # Insert at the beginning with '+'\n                                    # Almost same as .extend, except the original list is not changed in place!\n[5, 1, 2, 3]\n</code></pre> <pre><code>&gt;&gt;&gt; list = [1, 'deux', {'trois': 3 } ]  # A list doesn't require its elements to be different\n&gt;&gt;&gt; list = ['the','holy','grail']   # List ~ array are represented with square brackets\n&gt;&gt;&gt; nested_list = [ 'XXX', list]    # One of the elements of the list is a list\n&gt;&gt;&gt; 'XXX' in nested_list            # Check list membership\nTrue\n\n\n# The returned lists are not the original list (ie different id)\n# You cannot do l[1:].remove(3) and update the list l\n&gt;&gt;&gt; my_list[:]                      # The whole list\n&gt;&gt;&gt; my_list[0:]                     # The whole list (same as above)\n&gt;&gt;&gt; my-list[0:len(my_list)]         # The whole list (same as above)\n&gt;&gt;&gt; my_list[::1]                    # The whole list (same as above)\n&gt;&gt;&gt; my_list[2:]                     # From 3rd element to end\n&gt;&gt;&gt; my_list[2:-2]                   # From 3rd element to 2nd before last\n&gt;&gt;&gt; my_list[-1:] = [9]              # from the last element to the end\n&gt;&gt;&gt; my_list[-2:] = [8, 9]\n&gt;&gt;&gt; my_list[:-2:] = [0, 1, 2, 3, 4, 5, 6, 7]\n\n&gt;&gt;&gt; nested_list[1] = 'awesome'      # List are mutable!\n&gt;&gt;&gt; my_list.append('for sure')      # append 1 element only\n&gt;&gt;&gt; my_list.append(another_list)    # 'another_list' is placed at the end of the list as a single element\n&gt;&gt;&gt; my_list.insert(1,'super')       # inserting of an element without deletion\n&gt;&gt;&gt; my_list.remove('super')         # remove the FIRST 'super' entry from the list\n&gt;&gt;&gt; my_list = [x for x in my_list if x != 'super']  # remove all the 'super' entry\n\n&gt;&gt;&gt; my_list.extend(another_list)    # contact the 2 lists like the + operation, but my_list is changed in place!\n\n&gt;&gt;&gt; my_list.extend(another_list)      # contact the 2 lists like the + operation and change in place my_list !\n&gt;&gt;&gt; my_list = my_list + another_list  # same as above\n</code></pre> <pre><code>&gt;&gt;&gt; myList.index(\"revolves\")\n3\n&gt;&gt;&gt; \"revolves\" in myList\nTrue\n&gt;&gt;&gt; my_list.index(\"a\")\nException ValueError: 'a' is not in list\n</code></pre> <pre><code>token = string.split('\\t')      # Split on tab only\ntoken = string.split()          # Split on any space character\n</code></pre> <pre><code># Remove all the elements with a given value between 2 indexes of a list\ndef remove_between_indexes(lst, start, end, value):\n    return lst[:start] + [x for x in lst[start:end] if x != value] + lst[end:]\n\n# Example list\nmy_list = [\"keep\", \"remove_me\", \"keep\", \"remove_me\", \"keep\", \"remove_me\", \"keep\"]\n\n# Remove 'remove_me' between index 1 and 5\nnew_list = remove_between_indexes(my_list, 1, 5, \"remove_me\")\n\nprint(new_list)\n</code></pre></p>"},{"location":"python/#function-with-list-parameter","title":"function with list parameter","text":"<pre><code>len(lst)             - length of the list\nsorted(lst)          - &lt;!&gt; lst.sort()  &lt;== sort in place, but sorted(lst) sort the output\nsum(lst)             - sum of all the element of the list\n                     - &lt;!&gt; add to 0, so must be a number and not char/str/etc. !\nlst[::-1]            - &lt;!&gt; l.reverse() &lt;== reverse in place, but lst[::-1] reverse the output only!\n ...\n</code></pre>"},{"location":"python/#sorting","title":"sorting","text":"<p>. &lt;&gt;  * lst.sort change the list in place, while sorted doesn't!  * lst.sort can also use a function to sort the element of he list. see below  &lt;<p>&gt;  . &lt;!&gt; sort numbers first and then string ! ( = use LSD Radix sort first and then MSD Radix sort?)</p>"},{"location":"python/#sortedlst","title":"sorted(lst)","text":"<p>. &lt;!&gt; Deprecated? Use lst.sort() instead of sorted(l) ? No, lst.sort() = sort in place while sorted(lst) does not change lst!</p> <pre><code>sorted(range(30,20,-1))                                        # Turn range into a list and sort in numerical order\n\n&gt;&gt;&gt; sorted([\"a\", \"b\", \"ab\", \"z\", \"tutu\", \"aaa\", \"0\", \"2\"])     # Sort in alphabetical/dictionary order\n['a', 'aaa', 'ab', 'b', 'tutu', 'z']\n\n&gt;&gt;&gt; sorted([1, 2.3, 0.99, -23])                                # Sort in numerical/incremental order\n[-23, 0.99, 1, 2.3]\n\n&gt;&gt;&gt; sorted([1, 2, 3, 4, 'a', 'b', 2.4, 3])              # Python3 raise an exception\nTypeError: unorderable types: str() &lt; int()\n</code></pre> <pre><code># Sorting list of tuples use the first element of the tuple\n&gt;&gt;&gt; l = [ ('a',34), ('z', 23), ('b', 44)]\n&gt;&gt;&gt; sorted(l)\n[('a', 34), ('b', 44), ('z', 23)]\n\n# Sort based on 2nd field of tuple ~~~&gt; reverse tuple\n&gt;&gt;&gt; l = sorted(list(map(lambda el: el[::-1], l)))\n&gt;&gt;&gt; sorted(l)\n[(23, 'z'), (34, 'a'), (44, 'b')]\n</code></pre>"},{"location":"python/#lstsort","title":"lst.sort","text":"<p>. &lt;!&gt; Inplace sorting ! Not lie l2 = l1.sort() ... like sorted?</p> <pre><code>lst.sort()         # Like sorted, but change the list in place\n\nlst.sort(reverse=True)     # Sort in reverse order!\n\n&gt;&gt;&gt; list1=[[3,5,111],[16,23,21],[1,2,3,4],[100,1,31,12]]\n&gt;&gt;&gt; list1.sort(key=lambda x:x[1], reverse=True)                         # Sort based on a value extracted from each element/x!\n[[16, 23, 21], [3, 5, 111], [1, 2, 3, 4], [100, 1, 31, 12]]\n\n\n&gt;&gt;&gt; list1=[[100,200,300,400,500],[100,200,300],[100,150,200,400]]\n&gt;&gt;&gt; list1.sort(key=len)                                                 # using a FUNCTION REFERENCE to sort the elements, here the length function of the element\nprint(list1)\n[[100, 200, 300], [100, 150, 200, 400], [100, 200, 300, 400, 500]]\n\n\nlist1=[[10,200,300,40,500],[100,200,300],[100,150,200,400]]\nlist1.sort(key=sum)                                                     # using the key as sum on the element      sum([1,2]) == 3\nprint(list1)\n[[100, 200, 300], [100, 150, 200, 400], [10, 200, 300, 40, 500]]\n</code></pre>"},{"location":"python/#map-operation-on-every-element-of-a-list","title":"map : Operation on every element of a list","text":"<ul> <li>map() is used to execute a function on all the element of a list</li> <li>map() can also be used to work on multiple lists at once (list zip())</li> <li>if map() is using only one list as input, it can be done with a list comprehension!</li> <li> the output of map(...) is a map and not a list!</li> </ul> <p><pre><code>l = list(range(9))                  # Python3: Turn the iterator-like range into a list\nl = list(map(str, range(9))         # Python3: Turn the map object into a list\n\nl = [ ('a',34), ('z', 23), ('b', 44)]\nr = list(map(lambda el: el[::-1], l))    # [(34, 'a'), (23, 'z'), (44, 'b')]\nprint(r)\n[(44, 'b'), (23, 'z'), (34, 'a')]\n\n# Map with a function instead of a lambda!\ndef my_function(value):\n    \"\"\" Double provided value \"\"\"\n    return value + value\n\nmy_values = (1, 2, 3, 4)                # Can be a tuple or a list\nres = list(map(my_function, my_values))\n\nres = list(map(lambda v: v + v, my_values))   # Map with a lambda function !\n\n&gt;&gt;&gt; d                                   # beware list of chars, not index --&gt; string multiplication!\n['0', '1', '2', '3', '4', '5', '6', '7', '8']\n&gt;&gt;&gt; [ x*2 for x in d ]\n['00', '11', '22', '33', '44', '55', '66', '77', '88']\n\n\n# List of strings\nlist_of_strings = ['sat', 'bat', 'cat', 'mat']\n\n# map() can listify the list of strings individually\ntest = list(map(list, list_of_strings))\ntest                                    # returns [['s', 'a', 't'], ['b', 'a', 't'], ['c', 'a', 't'], ['m', 'a', 't']]\n</code></pre> <pre><code>s = 'hello world'\nlc = list(s)\n\n&gt;&gt;&gt; [ el.upper() for el in lc]\n['H', 'E', 'L', 'L', 'O', ' ', 'W', 'O', 'R', 'L', 'D']\n\n&gt;&gt;&gt; list(map(lambda el: el.upper(), lc))\n['H', 'E', 'L', 'L', 'O', ' ', 'W', 'O', 'R', 'L', 'D']\n</code></pre></p>"},{"location":"python/#working-with-2-lists-together-map","title":"Working with 2 lists together (map)","text":"<pre><code># Add two lists using map and lambda\n\nx_values = [1, 2, 3]\ny_values = [4, 5, 6]\n\nresult = map(lambda x, y: x + y, x_values, y_values)\n</code></pre>"},{"location":"python/#iteration-on-the-elements-of-a-list","title":"iteration on the elements of a list","text":"<p><pre><code>help(list.insert)\ninsert(self, index, object, /)\n    Insert object before index.\n</code></pre> <pre><code>ordered_words = ['aa', 'bb', 'ee', 'hh']\nwords = 'aaa,ddd'\n\n\ndef insert_word(word, ordered_words):\n    \"\"\" change ordered_words in place \"\"\"\n    for i, el_word in enumerate(ordered_words):\n        if word &lt; el_word:                        # Inequality on strings, sort based on ASCII characters' code! One by one chars\n            ordered_words.insert(i, word)         # Equivalent to ordered_words = ordered_words[:i] + [word] + ordered_words[i:]\n            break\n    return(true)\n\n\n\n\nwords = arg_w.split(',')\n\nfor w in words:\n    insert_word(w, ordered_words)\n\nprint ordered_words\n</code></pre></p>"},{"location":"python/#introspection_3","title":"Introspection","text":"<pre><code>&gt;&gt;&gt; l\n[9, 7, 5, 3, 1]\n\n&gt;&gt;&gt; type(l)\nlist\n\n&gt;&gt;&gt; dir(l)\n&gt;&gt;&gt; dir(list)\n['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']\n\n&gt;&gt;&gt; help(list.extend)\nextend(self, iterable, /)\n    Extend list by appending elements from the iterable.\n</code></pre>"},{"location":"python/#range","title":"Range","text":"<p>Not quite an iterator</p> <p>Range are iterator-like but not iterator, because they do not keep track of their state</p> <ul> <li>range is an iterable (not an iterator) that generates numbers lazily (when asked for it).</li> <li>You need to call iter(range(n)) to get an iterator from it (and get the 'next' method).</li> </ul> <p><pre><code>r = range(3)\nprint(next(r))  # \u274c TypeError: 'range' object is not an iterator\n</code></pre> <pre><code>r = iter(range(3))  # Creates an iterator from range   (call range.__iter__ method)\nprint(next(r))  # 0\nprint(next(r))  # 1\nprint(next(r))  # 2\nprint(next(r))  # \u274c Error! StopIteration\n</code></pre></p> <ul> <li>Using range is memory-efficient compared to storing a full list.</li> </ul>"},{"location":"python/#set","title":"Set","text":"<p>Sets are Unordered immutable elements with no duplicate.</p> <p>Sets are mutable</p> <p>What is a set:</p> <ul> <li>Every element in set is unique (no duplicates)</li> <li>Sets can be used to perform mathematical set operations like union, intersection, symmetric difference etc.</li> <li> Every element in set must be immutable (which cannot be changed) like strings, numbers, tuple, or range, however, the set itself is mutable. We can add or remove items from it.</li> </ul> <p>More at @ https://www.thegeekstuff.com/2019/04/python-set-examples/#more-17819</p>"},{"location":"python/#hands-on_3","title":"Hands-on","text":"<p><pre><code>Months={\"Jan\", \"Feb\", \"Mar\", \"Feb\"}                  # Will remove 1 \"Feb\" because not unique!\nDates={21,22,17}\n\n&gt;&gt;&gt; type(Dates)\nset\n\nDays = set([\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\",\"Sun\"])   # Turn a list in a set\n\n&gt;&gt;&gt; cars = ['honda','ford','dodge', 'honda']            # List\n&gt;&gt;&gt; autos = set(cars)                                   # Create a set from a list\n&gt;&gt;&gt; autos\nset(['dodge',chevy','honda', 'ford'])\n&gt;&gt;&gt; motos &amp; autos                                       # intersection of sets\n&gt;&gt;&gt; employees = engineers | programmers | managers      # union of sets\n&gt;&gt;&gt; engineering_management = engineers &amp; managers       # intersection of sets\n&gt;&gt;&gt; managers_only = employeses - engineers - programmers  # difference of sets\n</code></pre> <pre><code>s.update(t)                   # s |= t  return set s with elements added from t\ns.intersection_update(t)          # s &amp;= t  return set s keeping only elements also found in t\ns.difference_update(t)            # s -= t  return set s after removing elements found in t\ns.symmetric_difference_update(t)  # s ^= t  return set s ...\n                                  # ... with elements from s or t but not both\n\ns.add(x)       # add element x to set s (if x is not already there! If already there, tihs is a no-op!)\ns.remove(x)        # remove x from set s; raises KeyError if not present\ns.discard(x)       # removes x from set s if present (no exception)\ns.clear()          # remove all elements from set s\n\ns.pop()            # remove and return an arbitrary element from set s ...\n                   # ... raises KeyError if empty\n</code></pre></p> <p>Source @ [[https://docs.python.org/2/library/sets.html||target='_blank']]</p>"},{"location":"python/#introspection_4","title":"Introspection","text":"<pre><code>&gt;&gt;&gt; s = set()\n&gt;&gt;&gt; type(s)\nset\n\n&gt;&gt;&gt; dir(s)\n&gt;&gt;&gt; dir(set)\n['__and__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__iand__', '__init__', '__ior__', '__isub__', '__iter__', '__ixor__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__or__', '__rand__', '__reduce__', '__reduce_ex__', '__repr__', '__ror__', '__rsub__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__xor__', 'add', 'clear', 'copy', 'difference', 'difference_update', 'discard', 'intersection', 'intersection_update', 'isdisjoint', 'issubset', 'issuperset', 'pop', 'remove', 'symmetric_difference', 'symmetric_difference_update', 'union', 'update']\n\n&gt;&gt;&gt; help(set.update)\nupdate(...)\n    Update a set with the union of itself and others.\n</code></pre>"},{"location":"python/#frozenset","title":"Frozenset","text":"<p>A frozenset in Python is an immutable version of a set\u2014once created, you cannot add or remove elements from it.</p> <p>Key properties:</p> <ul> <li>Unordered collection of unique items (like a set)</li> <li>Immutable (unlike a set)</li> <li>Hashable, so it can be used as a key in dictionaries or as an element in other sets</li> </ul> <p>When to use:</p> <ul> <li>When you need a set-like collection that must not change</li> <li>When using sets as keys in a dictionary</li> </ul>"},{"location":"python/#hands-on_4","title":"Hands-on","text":"<pre><code># Create a frozenset\nfs = frozenset([1, 2, 3, 2])  # duplicates are removed\n\nprint(fs)  # Output: frozenset({1, 2, 3})\n\n# Attempting to modify it will raise an error\nfs.add(4)  # \u274c AttributeError: 'frozenset' object has no attribute 'add'\n</code></pre>"},{"location":"python/#dictionary","title":"Dictionary","text":"<p>Immutable keys</p> <p>keys must be of an immutable data type such as strings, numbers, or tuples.</p> <pre><code>d = {1: 'hello'}                     # d[1] = 'hello'\nd = {(1,2): 'hi'}                    # d[(1,2)] = 'hi'\nd = {'a_word': 'bonjour'}\nd = {'c':  'hello'}\n</code></pre>"},{"location":"python/#hands-on_5","title":"Hands-on","text":"How to set default values for the dictionary? <p>Use d.get('c', 'default_value')</p> How to remove a key from a dictionary? <p>Use \"del d['key']\"</p> <pre><code># Width dict comprehension\nmy_dict = {'a': 1, 'b': 2, 'c': 3, 'd': 4}\nkeys_to_remove = {'b', 'c'}\nfiltered_dict = {k: v for k, v in my_dict.items() if k not in keys_to_remove}\nprint(filtered_dict)\n\n# with d.pop('key')\nmy_dict = {'a': 1, 'b': 2, 'c': 3}\nvalue = my_dict.pop('b')\nprint(my_dict)  # {'a': 1, 'c': 3}\nprint(value)  # 2 (popped value)\n</code></pre> <pre><code>&gt;&gt;&gt; d = dict()\n&gt;&gt;&gt; d = {'key': 'value'}              # Dicts uses curly braces for their representation\n\n&gt;&gt;&gt; d = {'a': 1, 'b': 9}\n\n&gt;&gt;&gt; d['key']                          # Key must be unique and MUST EXIST ! Otherwise KeyError Exception\n'value'\n&gt;&gt;&gt; d.get(key)                        # Key must be unique, if does NOT exist return None\n&gt;&gt;&gt; d.get('c') is None\nTrue\n&gt;&gt;&gt; d.get(key) == 'value'             # False if key does NOT exist !\nFalse\n&gt;&gt;&gt; d.get(key, 'value_if_not_exist')  # A key if doesn't exist &lt;!&gt; Unlike setdefault, does not update the dictionary\n&gt;&gt;&gt; d.get('c','toto') == 'toto'\nTrue\n\n&gt;&gt;&gt; val = d.setdefault('toto', 2)           # Same as g.get('toto', 2) that is returns the dict value, but will update the dictionary in place\n&gt;&gt;&gt; val = d.setdefault('titi')              # Here the default value is None + update dictionary, same as d.setdefault('titi', None)\n&gt;&gt;&gt; d.setdefault('items', []).append(42)    # Great usage to init dict entries on the fly, with liss or sets!\n&gt;&gt;&gt; d.setdefault('tata', {'sub': 1} ) # Can be a complex default value!\n&gt;&gt;&gt; d.setdefault('l', []).append(2)   # will creaete the key/value pair if does not exist and append 2 to it &lt;!&gt; can fail if 'l' is different from a list!\n\n&gt;&gt;&gt; d['l2'] = d['l']                  # &lt;!&gt; not a copy of the list, but a reference to it!\n&gt;&gt;&gt; d['l2'].append(3)                 # append 3 to both list !!!!!\n\nd = {'a': 1, 'b': 2}\nv = d.setdefault('c', 100)            # Key 'c' doesn't exist, so it adds 'c': 100 and return 100\nprint(v)                              # 100\nprint(d)                              # {'a': 1, 'b': 2, 'c': 100}\n\n\nd['key'] = 'value'             # Add a new key/value pair in the dict\n'key' in d.keys()              # Check that the key is in dict (True)\ndel d['key']                   # remove key/value pair\n'key' in d.keys()              # Check that the key is in dict (False)\n\nd.keys()                       # returns all keys\nd.values()                     # Returns all the values (same order as d.keys())\n\n\ndel dict['Name'];                     # remove entry with key 'Name'\ndict.clear();                         # remove all entries in dict, dict is empty dictionary\ndel dict ;                            # delete entire dictionary, dict variable does not exist anymore\n\n\n&gt;&gt;&gt; d.items()                         # Iterator-like, list of tuples, but not an iterator!\ndict_items([('a', 1), ('b', 9)])\n\nlist(d.items())[1]                    # ('b', 2)\nlist(d.items())[0]                    # ('a', 1)\n\n&gt;&gt;&gt; for k in d                        # Iterate on the keys (same as d.keys())\n...     print(k)\n\n&gt;&gt;&gt; for kv in d.items():              # Get the kv tuples\n        print(kv)                     # print the tuple\n\n&gt;&gt;&gt; for key, value in d.items():      # Iterate on key and value pairs (was d.iteritems())\n                                      # returns a list of tuples\n...     print(key, ' -&gt; ', value)\n\n&gt;&gt;&gt; d = {'a': 1, 'b': 2}\n&gt;&gt;&gt; 'a' in d                          # A replacement for d.has_key()\nTrue\n\n&gt;&gt;&gt; d.get('a') != None\nTrue\n\n&gt;&gt;&gt; d.get('X') == None                # &lt;!&gt; When using 'dict.get', None is the default value if the key does not exist\nTrue\n</code></pre>"},{"location":"python/#map-on-dictionary-rebuild-all-k-v-pairs","title":"map on dictionary (rebuild ALL k-v pairs)","text":"<p>. &lt;!&gt; Also known as dictionary comprehension</p> <pre><code>def f(value):\n   return value**2\n\nmy_dictionary = {k: f(v) for k, v in my_dictionary.items()  if k == 1}       # Dict comprehension with filtering-condition!\n\n# or less readable\n\nmy_dictionary = dict(map(lambda kv: (kv[0], f(kv[1]) ), d.items()))    # d.items is a LIST of tuples fed to the lambda function!\n                                                                       # notice that the map is a map of tuples ... that is then turned into a dict\n                                                                       # similar to what d.items() would return... kv tuples!\n</code></pre> <p>Source @ https://stackoverflow.com/questions/12229064/mapping-over-values-in-a-python-dictionary</p>"},{"location":"python/#vs-shallow-copy-method-vs-copydeepcopy-function","title":"= vs shallow copy method vs copy.deepcopy function","text":"<p>. &lt;!&gt; with =, the dictionary points to exactly the same content (= identity ~ pointer) - change to immutable/mutable vars are propagated     * list or 'list_1 = list_2', this is not a copy but 2 variables pointing to the same memory space  . &lt;!&gt; with the copy dictionary method, the immutable are 'duplicated', the mutable are the same and change together  . &lt;!&gt; with copy.deepcopy, the 2 dictionaries are completely independent</p> <pre><code>&gt;&gt;&gt; d = {'a': 1, 'b': 2}\n&gt;&gt;&gt; dd = d                       # d and dd are the same !\n                                 # A change in one = a change in the other!\n&gt;&gt;&gt; id(d) == id(dd)\nTrue\n&gt;&gt;&gt; dd['a'] = 3\n&gt;&gt;&gt; print(d['a'])\n3\n</code></pre> <pre><code>import copy           # required for deepcopy, but not for copy!\n\notherDict = copy.deepcopy(wordsDict)           # Create a deep copy of the dictionary\n</code></pre> <p>. &lt;!&gt; With shallow copy, ---&gt; copy the object identities (values in particular, since key are immutables)    * the dictionary values that are mutable (list,...) when changed in one change in the other    * immutable (numbers, strings, tuple values) are NOT shared    * copy mutable (list dict, and set) by reference ==&gt; change a mutable's value == change in all dictionary!</p> <pre><code># create a Shallow copy  the original dictionary\nd = {'a': 1, 'b': 2, 'c': [1, 2, 3, 45]}\nd_copy = d.copy()\n\nd_copy[\"c\"].append(222)\n\nprint d                                        # The original dictionary has been changed!\n{'a': 1, 'c': [1, 2, 3, 45, 222], 'b': 2}\n\n&gt;&gt;&gt; d_copy['e'] = [3, 5, 4]                    # Add new element\n&gt;&gt;&gt; d\n{'a': 1, 'c': [1, 2, 3, 45, 222], 'b': 2}.     # new key is not in original dictionary !!!\n&gt;&gt;&gt; d_copy\n{'a': 1, 'c': [1, 2, 3, 45, 222], 'b': 2, 'e': [3, 5, 4]}\n</code></pre> <p>Source @ [[https://thispointer.com/python-how-to-copy-a-dictionary-shallow-copy-vs-deep-copy/||target='_blank']]</p> <pre><code>import copy\n\n# Original dictionary\noriginal = {'a': 1, 'b': [2, 3]}\n\n# Creating a shallow copy\nshallow = copy.copy(original)\n\n# Modifying the nested list\nshallow['b'].append(4)\n\nprint(original)  # {'a': 1, 'b': [2, 3, 4]}\nprint(shallow)   # {'a': 1, 'b': [2, 3, 4]} (Both changed!)\n\n# other ways to create shallow copies\nshallow = original.copy()  # Built-in method\nshallow = dict(original)   # Using dict() constructor\nshallow = {k: v for k, v in original.items()}  # Dictionary comprehension\n</code></pre> <pre><code># DEEP Copy\n\u2705 All nested objects are also copied.\n\u2705 No shared references\u2014each copy is fully independent.\n\nimport copy\n\n# Original dictionary with nested structure\noriginal = {'a': 1, 'b': [2, 3]}\n\n# Creating a deep copy\ndeep = copy.deepcopy(original)\n\n# Modifying the nested list\ndeep['b'].append(4)\n\nprint(original)  # {'a': 1, 'b': [2, 3]} (Original unchanged)\nprint(deep)      # {'a': 1, 'b': [2, 3, 4]} (Deep copy modified separately)\n</code></pre> <ul> <li>Use copy.copy() (shallow copy) when your dictionary contains only immutable values (numbers, strings, tuples).</li> <li>Use copy.deepcopy() (deep copy) when your dictionary has nested mutable objects (lists, sets, other dictionaries) and you want full independence.</li> </ul>"},{"location":"python/#hidden-dictionary","title":"Hidden dictionary","text":"<pre><code>Given a list of words, group the anagram in a sublist together\n['abc', 'bar', 'cab'] ---&gt; [ ['cab', 'abc'], ['bar']]\n\n   Def ana(L):                             # L is list of words\n    anagrams = {}\n    For word in L:\n        C = sorted(word)           # Reorder the chars of the word\n        If C not in anagrams:      # C is not a key in the dictionary\n            anagrams[C] = []\n        anagrams[C].append(word)   # = anagram_list\n    Return list(anagrams.values())           # return the values of anagrams dict\n</code></pre>"},{"location":"python/#map-on-dict-dict-comprehension","title":"map on dict = dict comprehension","text":"<p>. &lt;!&gt; Not quite an iterator but known as dictionary comprehension</p> <pre><code>def f(value):\n   return value**2\n\nmy_dictionary = {k: f(v) for k, v in my_dictionary.items()}\n\n# or less readable\n\nmy_dict = dict(map(lambda kv: (kv[0], f(kv[1])), my_dict.items()))\n\nmy_dict = dict(\n    map(lambda kv: (kv[0], f(kv[1]) ) , my_dict.items())           # dict( [ (k, v), ... ] ) ~~&gt; {k:v, ...}\n )\n\n# or\n\nfor k, v in d.items():\n    d['k'] = f(v)\n</code></pre> <p>Source @ https://stackoverflow.com/questions/12229064/mapping-over-values-in-a-python-dictionary</p>"},{"location":"python/#a-dictionary-of-functions-switch-case","title":"A dictionary of functions (switch ... case ...)","text":"<p>. &lt;!&gt; A dictionary of function  . &lt;!&gt; Key in dictionary are immutable numbers</p> <pre><code>import math\nfrom math import sqrt\n\ndef zero():                        # zero is a variable-reference to the function object!\n    print(\"You typed zero.\\n\")\n\ntype(zero)            # &lt;class 'function'&gt;\n\ndef sqr():\n    print(\"n is a perfect square\\n\")\n\ndef even():\n    print(\"n is an even number\\n\")\n\ndef prime():\n    print(\"n is a prime number\\n\")\n\n# All numbers from 0 to 9 are 'switch' keys, or keys in the option dictionary\noptions = {\n    0 : zero,\n    1 : sqr,         # function name/reference!\n    2 : even,\n    3 : prime,\n    4 : sqr,         # beware function need to be defined before reference is used\n    5 : prime,\n    6 : even,\n\n    7 : math.sqrt,            # import ...\n    8 : sqrt,                 # from math ...\n\n    9 : lambda x : x*x,       # yes, you can have 2 colon-chars in the same line ! The comma is the entry separator!\n    # * : lambda : None,      # See how to set the default function if not found!\n}\n\noptions[num]()\n</code></pre> <p>You gould also handle the missing default case by doing this instead:</p> <pre><code>options.get(num, lambda : None)()        # Default value for the function !\n\n&gt;&gt;&gt; d.get('*', lambda: None)() == None     # Beware: This is different from d.get('*', None)() which generate an exception because None() or None is not callable!\nTrue                                       # A lambda is callable!\n</code></pre> <p>Which will return None if num is not in options.</p> <p>&lt;&gt; <pre><code>def switch_example(value):\n    match value:\n        case 1:\n            print(\"One\")\n        case 2:\n            print(\"Two\")\n        case 3:\n            print(\"Three\")\n        case _:\n            print(\"Default case: Not 1, 2, or 3\")\n\nswitch_example(2)  # Output: Two\n</code></pre>"},{"location":"python/#jsonload-vs-eval","title":"json.load vs eval","text":"<p><pre><code># data.json\n{\n  \"name\": \"Alice\",\n  \"age\": 30,\n  \"is_student\": false\n}\n</code></pre> <pre><code>import json\n\n# Open and read the JSON file\nwith open('data.json', 'r') as file:\n    data = json.load(file)\n\n# Use the parsed data\nprint(data['name'])       # Output: Alice\nprint(data['age'])        # Output: 30\nprint(data['is_student']) # Output: False\n</code></pre></p> <ul> <li>string of a dict to dict</li> <li>source  @ https://stackoverflow.com/questions/988228/convert-a-string-representation-of-a-dictionary-to-a-dictionary   . Ex API call response</li> </ul>"},{"location":"python/#introspection_5","title":"introspection","text":"<pre><code>&gt;&gt;&gt; d = {}\n&gt;&gt;&gt; type(d)\n&lt;class 'dict'&gt;\n\n&gt;&gt;&gt; dir(dict)\n['__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']\n\n&gt;&gt;&gt; help(dict.keys())\nkeys(...)\n    D.keys() -&gt; a set-like object providing a view on D's keys\n</code></pre>"},{"location":"python/#function","title":"Function","text":""},{"location":"python/#object","title":"Object","text":"<pre><code>class Vector2D:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        if isinstance(other, Vector2D):\n            return Vector2D(self.x + other.x, self.y + other.y)\n        return NotImplemented\n\n    def __mul__(self, scalar):\n        if isinstance(scalar, (int, float)):\n            return Vector2D(self.x * scalar, self.y * scalar)\n        return NotImplemented\n\n    def __rmul__(self, scalar):\n        return self.__mul__(scalar)  # for scalar * vector\n\n    def __repr__(self):\n        return f\"Vector2D({self.x}, {self.y})\"\n</code></pre>"},{"location":"python/code-primer/","title":"Python Fundamentals > Code Primer","text":""},{"location":"python/code-primer/#code-primer","title":"Code Primer","text":"Arguments from command line<pre><code>#!/usr/bin/env python3\n\nimport sys\n\ndef main(argv):\n    assert len(argv) &gt;= 3, 'Too few parameters'\n    assert len(argv) &lt;= 1, 'No parameter to command line provided'\n    print(argv)\n\n    prog_name = argv[0]\n    argument_1 = argv[1]\n\n\nif __name__ == \"__main__\":     # when you run the python file, __name__ is set to \"__main__\"\n                               # Otherwise it is set to the module name\n    main(sys.argv)\n</code></pre> The invisible dictionary problem :-)<pre><code>#!/usr/bin/env python3\n\n# Given a list of words, group the anagram in a sublist together\n# ['abc', 'bar', 'cab'] ---&gt; [ ['cab', 'abc'], ['bar']]\n\ndef ana(L):                             # (1)\n    anagrams = {}\n    for word in L:\n        K = ''.join(sorted(word))       # (2)\n        if K not in anagrams.keys():    # (3)\n            anagrams[K] = []\n        anagrams[K].append(word)        # = anagram_list\n    dict_values = anagrams.values()     # &lt;!&gt; type is dict_values([['abc', 'cab'], ['bar']])\n    return( list(dict_values) )         # return the values of the anagrams dict in a list format\n\n# ana(['abc', 'bar', 'cab'])[0]\n# Traceback (most recent call last):\n#   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n# TypeError: 'dict_values' object is not subscriptable\n# list(ana(['abc', 'bar', 'cab']))[0]\n# ['abc', 'cab']\n</code></pre> <ol> <li>L is list of words</li> <li>Reorder the chars of the word     sorted(word) ==&gt; list of ordered characters as if 'word' was a list of char     sorted('akc') ==&gt; ['a', 'c', 'k']</li> <li>K is NOT already a key in the dictionary     ... create key/entry + initialize</li> </ol> Add elements in two lists<pre><code>x_values_list = [1, 2, 3] \ny_values_list = [4, 5, 6] \n\nm = map(lambda x, y: x + y, x_values_list, y_values_list)     # m is &lt;map at 0x104a65180&gt;\n                                                              # similar to: for x, y in zip(x_values_list, y_values_list) ? Almost!\n                                                              # zip returns an iterable on tuples, not a map object!\ntype(m)                                                       # m is a map\nlist(m)                                                       # a list ;-)   or [5, 7, 9]\n\nret_list = list(map(lambda x, y: x + y, x_values_list, y_values_list))   # Add list for Python3\nret_list = list(map(lambda x: x**2, x_values_list))\n</code></pre> Sorting list of tuples uses the first element of the tuple<pre><code>&gt;&gt;&gt; _list = [ ('a',34), ('z', 23), ('b', 44)]\n&gt;&gt;&gt; sorted(_list)                                 # sort list items based on the first value in the \n[('a', 34), ('b', 44), ('z', 23)]\n\n# (DEPRECATED) Sort based on 2nd field of tuple ~~~&gt; reverse tuple\n&gt;&gt;&gt; _list = sorted(list(map(lambda el: el[::-1], _list)))\n\n# &gt;&gt;&gt; el_values_list = _list                                            # Those 2 lines ... \n# &gt;&gt;&gt; _list = sorted(list(map(lambda el: el[::-1], el_values_list)))    # ... do the same as above! \n\n&gt;&gt;&gt; sorted(_list)                              # Sort the elements of a list... using the first value in each element! \n[(23, 'z'), (34, 'a'), (44, 'b')]\n</code></pre> Sorting list of tuples using the 2 element of each tuple<pre><code>data = [(\"apple\", 3), (\"banana\", 1), (\"cherry\", 2)]\n\n# Sort by second element (index 1)\nsorted_data = sorted(data, key=lambda x: x[1])\n\nprint(sorted_data)\n# Output: [('banana', 1), ('cherry', 2), ('apple', 3)]\n</code></pre> List comprehension<pre><code>&gt;&gt;&gt; [ c*2 for c in \"012345678\" ]\n['00', '11', '22', '33', '44', '55', '66', '77', '88']\n\n# Dictionary comprehension\n# build a new dictionary using a function\nmy_dictionary_comprehension = {k: f(v) for k, v in d.items()  if k == 1}\n\n# Fct\ndef myfunc(self, *args, **kwargs) :    # args is a tuple, kwargs is a dict\n</code></pre> Getting help<pre><code>import my_module as mm\nhelp(mm)                     # print the docstring of the module + of functions\nhelp(mm.greet)               # print the docstring of the given function in the module\nhelp(WHATEVER)               # &lt;== prints docstrings\nhelp()                       # &lt;== help in interactive mode\n\nhelp(dir)\ndir()                        # List variables/names in the current scope\ndir(int)                     # dir (&lt;class&gt;) --&gt; list methods of &lt;class&gt;\nhelp(int.to_bytes)           # help ( &lt;class&gt;.&lt;method&gt; )\ndir(WHATEVER)                &lt;== returns a list of variables in scope of methods\n\nassert 3/4 &gt; 1, \"not so fast!\"  # raise AssertionError with explanation\nhelp(assert)                 # Fails, assert is a statement, not a function, i.e. assert()!\nhelp(assert.__doc__)         # Fails \nhelp('assert')               # Works! help for the standalone command 'assert'\n\n\nhelp(str)                    # return info for method and class for 'str' objects\nhelp(str.__doc__)            # ok, works, but not formatted correctly\nprint(str.__doc__)           # print the help for the 'str' type conversion function\n\n&lt;!&gt; If module was already loaded, you need to reload it!\nimport importlib\nimportlib.reload(my_module)  # or .reload(mm)\n</code></pre> Primer with doctests<pre><code># To run if testmod block is not present: python -m doctest your_file.py\n# Python will automatically scan the file for docstring tests and run them.\ndef add(a, b):\n    \"\"\"\n    Returns the sum of a and b.\n\n    &gt;&gt;&gt; add(2, 3)\n    5\n    &gt;&gt;&gt; add(-1, 1)\n    0\n    \"\"\"\n    return a + b\n\n# To run the tests (with testmod() block ): python calculator.py\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n</code></pre> Primer with Python debugger<pre><code>import pdb\n\ndef add(a, b):\n    pdb.set_trace()                               # Execution will pause here (when run with pdb)\n    return a + b\n\nresult = add(3, 5)\nprint(result)\n\n\n\n$ python -m pdb my_script.py                      # run the pdb\n\npdb\n# operations\nn | next\ns | step               - step into a function call\nc | continue           - continue exection until next breakbpoint\nr | return             - continue execution until function returns\nq | quit               - quit debugger\n\nb 10                   - set a breakpoint at line 10\nl | list               - list all breakpoints\n\n\np variable             - print the value of a variable\npp variable            - pretty print of a variable\n</code></pre>"},{"location":"python/dictionary/","title":"Python Fundamentals > Dictionary","text":""},{"location":"python/dictionary/#dictionary","title":"Dictionary","text":"<p>Immutable keys</p> <p>keys must be of an immutable data type such as strings, numbers, or tuples.</p> <pre><code>d = {1: 'hello'}                     # d[1] = 'hello'\nd = {(1,2): 'hi'}                    # d[(1,2)] = 'hi'\nd = {'a_word': 'bonjour'}\nd = {'c':  'hello'}\n</code></pre>"},{"location":"python/dictionary/#hands-on","title":"Hands-on","text":"How to set default values for the dictionary? <p>Use d.get('c', 'default_value')</p> How to remove a key from a dictionary? <p>Use \"del d['key']\"</p> <pre><code># Width dict comprehension\nmy_dict = {'a': 1, 'b': 2, 'c': 3, 'd': 4}\nkeys_to_remove = {'b', 'c'}\nfiltered_dict = {k: v for k, v in my_dict.items() if k not in keys_to_remove}\nprint(filtered_dict)\n\n# with d.pop('key')\nmy_dict = {'a': 1, 'b': 2, 'c': 3}\nvalue = my_dict.pop('b')\nprint(my_dict)  # {'a': 1, 'c': 3}\nprint(value)  # 2 (popped value)\n</code></pre> <pre><code>&gt;&gt;&gt; d = dict()\n&gt;&gt;&gt; d = {'key': 'value'}              # Dicts uses curly braces for their representation\n\n&gt;&gt;&gt; d = {'a': 1, 'b': 9}\n\n&gt;&gt;&gt; d['key']                          # Key must be unique and MUST EXIST ! Otherwise KeyError Exception\n'value'\n&gt;&gt;&gt; d.get(key)                        # Key must be unique, if does NOT exist return None\n&gt;&gt;&gt; d.get('c') is None\nTrue\n&gt;&gt;&gt; d.get(key) == 'value'             # False if key does NOT exist !\nFalse\n&gt;&gt;&gt; d.get(key, 'value_if_not_exist')  # A key if doesn't exist &lt;!&gt; Unlike setdefault, does not update the dictionary\n&gt;&gt;&gt; d.get('c','toto') == 'toto'\nTrue\n\n&gt;&gt;&gt; val = d.setdefault('toto', 2)           # Same as g.get('toto', 2) that is returns the dict value, but will update the dictionary in place\n&gt;&gt;&gt; val = d.setdefault('titi')              # Here the default value is None + update dictionary, same as d.setdefault('titi', None)\n&gt;&gt;&gt; d.setdefault('items', []).append(42)    # Great usage to init dict entries on the fly, with liss or sets!\n&gt;&gt;&gt; d.setdefault('tata', {'sub': 1} ) # Can be a complex default value!\n&gt;&gt;&gt; d.setdefault('l', []).append(2)   # will creaete the key/value pair if does not exist and append 2 to it &lt;!&gt; can fail if 'l' is different from a list!\n\n&gt;&gt;&gt; d['l2'] = d['l']                  # &lt;!&gt; not a copy of the list, but a reference to it!\n&gt;&gt;&gt; d['l2'].append(3)                 # append 3 to both list !!!!!\n\nd = {'a': 1, 'b': 2}\nv = d.setdefault('c', 100)            # Key 'c' doesn't exist, so it adds 'c': 100 and return 100\nprint(v)                              # 100\nprint(d)                              # {'a': 1, 'b': 2, 'c': 100}\n\n\nd['key'] = 'value'             # Add a new key/value pair in the dict\n'key' in d.keys()              # Check that the key is in dict (True)\ndel d['key']                   # remove key/value pair\n'key' in d.keys()              # Check that the key is in dict (False)\n\nd.keys()                       # returns all keys\nd.values()                     # Returns all the values (same order as d.keys())\n\n\ndel dict['Name'];                     # remove entry with key 'Name'\ndict.clear();                         # remove all entries in dict, dict is empty dictionary\ndel dict ;                            # delete entire dictionary, dict variable does not exist anymore\n\n\n&gt;&gt;&gt; d.items()                         # Iterator-like, list of tuples, but not an iterator!\ndict_items([('a', 1), ('b', 9)])\n\nlist(d.items())[1]                    # ('b', 2)\nlist(d.items())[0]                    # ('a', 1)\n\n&gt;&gt;&gt; for k in d                        # Iterate on the keys (same as d.keys())\n...     print(k)\n\n&gt;&gt;&gt; for kv in d.items():              # Get the kv tuples\n        print(kv)                     # print the tuple\n\n&gt;&gt;&gt; for key, value in d.items():      # Iterate on key and value pairs (was d.iteritems())\n                                      # returns a list of tuples\n...     print(key, ' -&gt; ', value)\n\n&gt;&gt;&gt; d = {'a': 1, 'b': 2}\n&gt;&gt;&gt; 'a' in d                          # A replacement for d.has_key()\nTrue\n\n&gt;&gt;&gt; d.get('a') != None\nTrue\n\n&gt;&gt;&gt; d.get('X') == None                # &lt;!&gt; When using 'dict.get', None is the default value if the key does not exist\nTrue\n</code></pre>"},{"location":"python/dictionary/#map-on-dictionary-rebuild-all-k-v-pairs","title":"map on dictionary (rebuild ALL k-v pairs)","text":"<p>. &lt;!&gt; Also known as dictionary comprehension</p> <pre><code>def f(value):\n   return value**2\n\nmy_dictionary = {k: f(v) for k, v in my_dictionary.items()  if k == 1}       # Dict comprehension with filtering-condition!\n\n# or less readable\n\nmy_dictionary = dict(map(lambda kv: (kv[0], f(kv[1]) ), d.items()))    # d.items is a LIST of tuples fed to the lambda function!\n                                                                       # notice that the map is a map of tuples ... that is then turned into a dict\n                                                                       # similar to what d.items() would return... kv tuples!\n</code></pre> <p>Source @ https://stackoverflow.com/questions/12229064/mapping-over-values-in-a-python-dictionary</p>"},{"location":"python/dictionary/#vs-shallow-copy-method-vs-copydeepcopy-function","title":"= vs shallow copy method vs copy.deepcopy function","text":"<p>. &lt;!&gt; with =, the dictionary points to exactly the same content (= identity ~ pointer) - change to immutable/mutable vars are propagated     * list or 'list_1 = list_2', this is not a copy but 2 variables pointing to the same memory space  . &lt;!&gt; with the copy dictionary method, the immutable are 'duplicated', the mutable are the same and change together  . &lt;!&gt; with copy.deepcopy, the 2 dictionaries are completely independent</p> <pre><code>&gt;&gt;&gt; d = {'a': 1, 'b': 2}\n&gt;&gt;&gt; dd = d                       # d and dd are the same !\n                                 # A change in one = a change in the other!\n&gt;&gt;&gt; id(d) == id(dd)\nTrue\n&gt;&gt;&gt; dd['a'] = 3\n&gt;&gt;&gt; print(d['a'])\n3\n</code></pre> <pre><code>import copy           # required for deepcopy, but not for copy!\n\notherDict = copy.deepcopy(wordsDict)           # Create a deep copy of the dictionary\n</code></pre> <p>. &lt;!&gt; With shallow copy, ---&gt; copy the object identities (values in particular, since key are immutables)    * the dictionary values that are mutable (list,...) when changed in one change in the other    * immutable (numbers, strings, tuple values) are NOT shared    * copy mutable (list dict, and set) by reference ==&gt; change a mutable's value == change in all dictionary!</p> <pre><code># create a Shallow copy  the original dictionary\nd = {'a': 1, 'b': 2, 'c': [1, 2, 3, 45]}\nd_copy = d.copy()\n\nd_copy[\"c\"].append(222)\n\nprint d                                        # The original dictionary has been changed!\n{'a': 1, 'c': [1, 2, 3, 45, 222], 'b': 2}\n\n&gt;&gt;&gt; d_copy['e'] = [3, 5, 4]                    # Add new element\n&gt;&gt;&gt; d\n{'a': 1, 'c': [1, 2, 3, 45, 222], 'b': 2}.     # new key is not in original dictionary !!!\n&gt;&gt;&gt; d_copy\n{'a': 1, 'c': [1, 2, 3, 45, 222], 'b': 2, 'e': [3, 5, 4]}\n</code></pre> <p>Source @ [[https://thispointer.com/python-how-to-copy-a-dictionary-shallow-copy-vs-deep-copy/||target='_blank']]</p> <pre><code>import copy\n\n# Original dictionary\noriginal = {'a': 1, 'b': [2, 3]}\n\n# Creating a shallow copy\nshallow = copy.copy(original)\n\n# Modifying the nested list\nshallow['b'].append(4)\n\nprint(original)  # {'a': 1, 'b': [2, 3, 4]}\nprint(shallow)   # {'a': 1, 'b': [2, 3, 4]} (Both changed!)\n\n# other ways to create shallow copies\nshallow = original.copy()  # Built-in method\nshallow = dict(original)   # Using dict() constructor\nshallow = {k: v for k, v in original.items()}  # Dictionary comprehension\n</code></pre> <pre><code># DEEP Copy\n\u2705 All nested objects are also copied.\n\u2705 No shared references\u2014each copy is fully independent.\n\nimport copy\n\n# Original dictionary with nested structure\noriginal = {'a': 1, 'b': [2, 3]}\n\n# Creating a deep copy\ndeep = copy.deepcopy(original)\n\n# Modifying the nested list\ndeep['b'].append(4)\n\nprint(original)  # {'a': 1, 'b': [2, 3]} (Original unchanged)\nprint(deep)      # {'a': 1, 'b': [2, 3, 4]} (Deep copy modified separately)\n</code></pre> <ul> <li>Use copy.copy() (shallow copy) when your dictionary contains only immutable values (numbers, strings, tuples).</li> <li>Use copy.deepcopy() (deep copy) when your dictionary has nested mutable objects (lists, sets, other dictionaries) and you want full independence.</li> </ul>"},{"location":"python/dictionary/#hidden-dictionary","title":"Hidden dictionary","text":"<pre><code>Given a list of words, group the anagram in a sublist together\n['abc', 'bar', 'cab'] ---&gt; [ ['cab', 'abc'], ['bar']]\n\n   Def ana(L):                             # L is list of words\n    anagrams = {}\n    For word in L:\n        C = sorted(word)           # Reorder the chars of the word\n        If C not in anagrams:      # C is not a key in the dictionary\n            anagrams[C] = []\n        anagrams[C].append(word)   # = anagram_list\n    Return list(anagrams.values())           # return the values of anagrams dict\n</code></pre>"},{"location":"python/dictionary/#map-on-dict-dict-comprehension","title":"map on dict = dict comprehension","text":"<p>. &lt;!&gt; Not quite an iterator but known as dictionary comprehension</p> <pre><code>def f(value):\n   return value**2\n\nmy_dictionary = {k: f(v) for k, v in my_dictionary.items()}\n\n# or less readable\n\nmy_dict = dict(map(lambda kv: (kv[0], f(kv[1])), my_dict.items()))\n\nmy_dict = dict(\n    map(lambda kv: (kv[0], f(kv[1]) ) , my_dict.items())           # dict( [ (k, v), ... ] ) ~~&gt; {k:v, ...}\n )\n\n# or\n\nfor k, v in d.items():\n    d['k'] = f(v)\n</code></pre> <p>Source @ https://stackoverflow.com/questions/12229064/mapping-over-values-in-a-python-dictionary</p>"},{"location":"python/dictionary/#a-dictionary-of-functions-switch-case","title":"A dictionary of functions (switch ... case ...)","text":"<p>. &lt;!&gt; A dictionary of function  . &lt;!&gt; Key in dictionary are immutable numbers</p> <pre><code>import math\nfrom math import sqrt\n\ndef zero():                        # zero is a variable-reference to the function object!\n    print(\"You typed zero.\\n\")\n\ntype(zero)            # &lt;class 'function'&gt;\n\ndef sqr():\n    print(\"n is a perfect square\\n\")\n\ndef even():\n    print(\"n is an even number\\n\")\n\ndef prime():\n    print(\"n is a prime number\\n\")\n\n# All numbers from 0 to 9 are 'switch' keys, or keys in the option dictionary\noptions = {\n    0 : zero,\n    1 : sqr,         # function name/reference!\n    2 : even,\n    3 : prime,\n    4 : sqr,         # beware function need to be defined before reference is used\n    5 : prime,\n    6 : even,\n\n    7 : math.sqrt,            # import ...\n    8 : sqrt,                 # from math ...\n\n    9 : lambda x : x*x,       # yes, you can have 2 colon-chars in the same line ! The comma is the entry separator!\n    # * : lambda : None,      # See how to set the default function if not found!\n}\n\noptions[num]()\n</code></pre> <p>You gould also handle the missing default case by doing this instead:</p> <pre><code>options.get(num, lambda : None)()        # Default value for the function !\n\n&gt;&gt;&gt; d.get('*', lambda: None)() == None     # Beware: This is different from d.get('*', None)() which generate an exception because None() or None is not callable!\nTrue                                       # A lambda is callable!\n</code></pre> <p>Which will return None if num is not in options.</p> <p>&lt;&gt; <pre><code>def switch_example(value):\n    match value:\n        case 1:\n            print(\"One\")\n        case 2:\n            print(\"Two\")\n        case 3:\n            print(\"Three\")\n        case _:\n            print(\"Default case: Not 1, 2, or 3\")\n\nswitch_example(2)  # Output: Two\n</code></pre>"},{"location":"python/dictionary/#jsonload-vs-eval","title":"json.load vs eval","text":"<p><pre><code># data.json\n{\n  \"name\": \"Alice\",\n  \"age\": 30,\n  \"is_student\": false\n}\n</code></pre> <pre><code>import json\n\n# Open and read the JSON file\nwith open('data.json', 'r') as file:\n    data = json.load(file)\n\n# Use the parsed data\nprint(data['name'])       # Output: Alice\nprint(data['age'])        # Output: 30\nprint(data['is_student']) # Output: False\n</code></pre></p> <ul> <li>string of a dict to dict</li> <li>source  @ https://stackoverflow.com/questions/988228/convert-a-string-representation-of-a-dictionary-to-a-dictionary   . Ex API call response</li> </ul>"},{"location":"python/dictionary/#introspection","title":"introspection","text":"<pre><code>&gt;&gt;&gt; d = {}\n&gt;&gt;&gt; type(d)\n&lt;class 'dict'&gt;\n\n&gt;&gt;&gt; dir(dict)\n['__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']\n\n&gt;&gt;&gt; help(dict.keys())\nkeys(...)\n    D.keys() -&gt; a set-like object providing a view on D's keys\n</code></pre>"},{"location":"python/frozenset/","title":"Python Fundamentals > Frozenset","text":""},{"location":"python/frozenset/#frozenset","title":"Frozenset","text":"<p>A frozenset in Python is an immutable version of a set\u2014once created, you cannot add or remove elements from it.</p> <p>Key properties:</p> <ul> <li>Unordered collection of unique items (like a set)</li> <li>Immutable (unlike a set)</li> <li>Hashable, so it can be used as a key in dictionaries or as an element in other sets</li> </ul> <p>When to use:</p> <ul> <li>When you need a set-like collection that must not change</li> <li>When using sets as keys in a dictionary</li> </ul>"},{"location":"python/frozenset/#hands-on","title":"Hands-on","text":"<pre><code># Create a frozenset\nfs = frozenset([1, 2, 3, 2])  # duplicates are removed\n\nprint(fs)  # Output: frozenset({1, 2, 3})\n\n# Attempting to modify it will raise an error\nfs.add(4)  # \u274c AttributeError: 'frozenset' object has no attribute 'add'\n</code></pre>"},{"location":"python/function/","title":"Python Fundamentals > Function","text":""},{"location":"python/function/#function","title":"Function","text":""},{"location":"python/glossary/","title":"Python Fundamentals > Glossary","text":""},{"location":"python/glossary/#glossary","title":"Glossary","text":"Concurrency <p>Concurrency is concerned with managing access to shared state from different threads. Beware concurrency and parallelism are distinct concepts. Parallelism is concerned with utilizing multiple processors/cores to improve the performance of a computation. </p> Container Object <p>Some objects contain references to other objects, these objects are called containers. Some examples of container-objects are a tuple, list, and dictionary. The value of an immutable container that contains a reference to a mutable object can be changed if that mutable object is changed. However, the container is still considered immutable because when we talk about the mutability of a container only the identities of the contained objects are implied. <pre><code>&gt;&gt;&gt; t = ([1,2], [0])           # a tuple of 2 lists\n&gt;&gt;&gt; t[0].append(3)             # the list are mutable containers !\n&gt;&gt;&gt; t\n([1, 2, 3], [0])\n</code></pre></p> <p>But <pre><code>&gt;&gt;&gt; t[0] = 1                   # ... but the tuple is not a mutable container, so id(t[0]) cannot change !\nTypeError: 'tuple' object does not support item assignment\n</code></pre></p> <p>See also Mutability</p> Decorator <p>A function that takes a function as input and return another function!  decorators wrap a function, modifying its behavior. i.e the return function is assigned to the initial function variable ! <pre><code>my_function = my_decorator(my_function)\n</code></pre></p> Deep Copy  <p>A deep copy duplicates not just the outer object (like a list), but also all the nested mutable objects inside it. In contrast, a shallow copy only duplicates the outer container \u2014 the inner elements are still references to the same objects. <pre><code>import copy\n\noriginal = [[1, 2], [3, 4]]\n\nshallow = copy.copy(original)   # Could also be original[:] if original is a sequence\n                                # or original.copy() if object supports it (lists, dicts, sets only)\n                                # copy.copy is for any object that supports it!\ndeep = copy.deepcopy(original)\n\n# Change an inner value\noriginal[0][0] = 99\n\nprint(\"Original:\", original)   # [[99, 2], [3, 4]]\nprint(\"Shallow:\", shallow)     # [[99, 2], [3, 4]] \u2014 changed!\nprint(\"Deep:\", deep)           # [[1, 2], [3, 4]] \u2014 unchanged \u2705\n</code></pre></p> Global Interpreter Lock (GIL) <p>The Python threading module uses threads instead of processes. Threads run in the same unique memory heap. Whereas Processes run in separate memory heaps. This, makes sharing information harder with processes and object instances. One problem arises because threads use the same memory heap, multiple threads can write to the same location in the memory heap which is why the default Python interpreter has a thread-safe mechanism, the \u201cGIL\u201d (Global Interpreter Lock). This prevent conflicts between threads, by executing only one statement at a time (serial processing, or single-threading).</p> <p>The Global Interpretor Lock (GIL) in CPython prevents parallel threads of execution on multiple cores, thus the threading implementation on python is useful mostly for concurrent thread implementation in web-servers.</p> <p>More at https://blog.usejournal.com/multithreading-vs-multiprocessing-in-python-c7dc88b50b5b</p> Identity <p>~ pointer to memory area (memory address)??? An object as a type, value, and identity -- type and identity of the object stays constant! In Python, a reference is not directly exposed, but you can work with it using the object's memory address (id()) or weak references. <pre><code>&gt;&gt;&gt; id([1,2])\n4382416128\n&gt;&gt;&gt; id([1,2])\n4382416128\n&gt;&gt;&gt; a = [1,2]               &lt;== variable\n&gt;&gt;&gt; id([1,2])\n4382422528\n&gt;&gt;&gt; id(a)                   &lt;== variable points to the identity of the assigned object, the identity is used by variables and container objects\n4382416128\n</code></pre> <pre><code>&gt;&gt;&gt; s = 'hello'\n&gt;&gt;&gt; id(s)\n4384848624\n&gt;&gt;&gt; sorted(s)\n['e', 'h', 'l', 'l', 'o']\n&gt;&gt;&gt; id(s)\n4384848624\n&gt;&gt;&gt; id(sorted(s))\n4385528064\n</code></pre> <pre><code>&gt;&gt;&gt; our_str ='Bonjour Monde'\n&gt;&gt;&gt; id(our_str)\n4382424112                        &lt;== ok\n&gt;&gt;&gt; our_str = 'Hello World'\n&gt;&gt;&gt; id(our_str)\n4385028914                        &lt;== new string, new id!\n</code></pre> <pre><code>&gt;&gt;&gt; h = 'hello'\n&gt;&gt;&gt; w = 'world'\n&gt;&gt;&gt; h + ' ' + w\n'hello world'\n&gt;&gt;&gt; id(h)\n4382424112\n&gt;&gt;&gt; h = h + ' ' + w\n&gt;&gt;&gt; id(h)\n4384848624\n&gt;&gt;&gt; h\n'hello world'\n</code></pre></p> <p>See also Type</p> Immutable <p>Keys in dictionaries have to be immutable (so can be hashed!) meaning only strings, numbers, frozensets, tuples, bool, range can be dictionary keys</p> Method Resolution Order (MRO) <p>A list of classes. The first is the object at hand, the next ones are the parent classES, followed by the grandparent classES...</p> Mutability <p>The value of some objects can change (an object as a type, value, and identity -- type and identity of the object stays constant!). Objects whose value can change are said to be mutable (list, dict, set can be changed after their creation); objects whose value is unchangeable once they are created are called immutable (e.g. numbers, tuples, strings, frozensets, bools, ranges)</p> <p>See also Container Object</p> Parallelism <p>Parallelism is concerned with utilizing multiple processors/cores to improve the performance of a computation. Beware parallelism and concurrency are distinct concepts. Concurrency is concerned with managing access to shared state from different threads.</p> Reference <p>In Python, a reference is a name that points to an object in memory. When you assign a variable to a value, you're actually assigning a reference to that object, not copying the data itself.  The variables hold references, not values <pre><code>a = [1, 2, 3]          # 'a' holds a reference to the list [1, 2, 3]\nb = a                  # 'b' is another reference to the same list\n\n# Both a and b reference the same list in memory.\n# Modifying one affects the other.\n\nb.append(4)            # Modify the list using the 'b' variable\n\nprint(a)               # [1, 2, 3, 4]\nprint(b)               # [1, 2, 3, 4] (same list)\n</code></pre> <pre><code>a = [1, 2, 3]\nb = a.copy()           # Creates a new list (a shallow copy)\n                       # similar to a[:] ?\n\nb.append(4)            # Modify 'b' only\n\nprint(a)               # [1, 2, 3] (original remains unchanged)\nprint(b)               # [1, 2, 3, 4] (new copy)\n</code></pre> <pre><code>x = [10, 20, 30]\ny = x                  # y references the same object\n\nprint(id(x) == id(y))  # \u2705 True (same object)\n</code></pre> <pre><code>z = x.copy()\nprint(id(x) == id(z))  # \u274c False (different objects) &lt;-- different object because different memory space!\n</code></pre> <pre><code>a = 100\nb = 100\nprint(id(a) == id(b))  # \u2705 True (same reference)\n\nx = \"hello\"\ny = \"hello\"\nprint(id(x) == id(y))  # \u2705 True (Python reuses string literals)\n</code></pre></p> Shallow Copy <p>A shallow copy only duplicates the outer container \u2014 the inner elements are still references to the same objects. In contrast, a deep copy duplicates not just the outer object (like a list), but also all the nested mutable objects inside it.</p> Thread <p>Multiple threads live in the same process in the same space, each thread will do a specific task, have its own code, own stack memory, instruction pointer, and share heap/virtual memory. If a thread has a memory leak it can damage the other threads and parent process. </p> <p>See also Global Interpreter Lock</p> Type <p>Example <pre><code>&gt;&gt;&gt; type((1,2))\n&lt;class 'tuple'&gt;\n&gt;&gt;&gt; type('hello')\n&lt;class 'str'&gt;\n</code></pre></p> <p>See also Identity</p> Value <p>See also Identity and Type</p>"},{"location":"python/list/","title":"Python Fundamentals > List","text":""},{"location":"python/list/#list","title":"List","text":"<p>Indexed to 0</p> <ul> <li>Lists are indexed to 0</li> <li>First element in the list is at index 0 !!!</li> </ul>"},{"location":"python/list/#hands-on","title":"Hands-on","text":"<p>How do you copy a list?</p> <p>You do NOT copy a list with 'list_0 = list_1', but with  'list0 = list1[:]' for shallow copies and </p> <pre><code>import copy\n\nlst = [[1, 2], [3, 4]]       # A list of mutable elements!\ndeep = copy.deepcopy(lst)    # An entirely different copy\n</code></pre> <p><pre><code>list_0 = [0,1]\nlist_0 = list(range(10))        # Python3: range is an iterator-like, but not an iterator!\nid(list_0)                      # ex: 4368873792\n\nlist_1 = list_0                 # Here you have 2 variables thet refers to the same list object, not a copy!  &lt;-- variables points to the same identity\nid(list_1)                      # ex: 4368873792\n\n\nlist_1[2] = 'X'                 # Changing one will change the other!\nlist_0                          # [0, 1, 'X', 3, 4, 5, 6, 7, 8, 9]\n\nlist_1 = list_0[:]              # This is how to copy a list!     &lt;-- 2 different identities!\nlist_1[3] = 'Y'                 # Will NOT change what list_0 is pointing to! If you change one, you do NOT change the other!\nlist_1                          # [0, 1, 'X', 'Y', 4, 5, 6, 7, 8, 9]\n\nlist_0                          # [0, 1, 'X', 3, 4, 5, 6, 7, 8, 9]\n</code></pre> <pre><code>a = range(10)                       # range(0,10) or 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\na\nb = range(1,11)                     # range(1, 11) or 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\nb\nc = range(30,20,-1)                 # range(30, 20, -1) or 30, 29, 28, ..., 22, 21\nc\n\n\n&gt;&gt;&gt; square=[i**2 for i in a]            # List comprehension\n&gt;&gt;&gt; square=[i**2 for i in range(10)]\n\n[\"Even\" if x % 2 == 0 else \"Odd\" for x in range(5)]    # ['Even', 'Odd', 'Even', 'Odd', 'Even']\n\n\n\u2705 More Readable: Less boilerplate than loops.\n\u2705 Faster: Optimized for performance compared to for loops.\n\u2705 Memory Efficient: Combined with generators, it can reduce memory usage. (generators create values as they are read instead of first and then reading them from memory (as with regular lists)\n</code></pre></p> <p>. &lt;!&gt; &lt;&gt; <p><pre><code>&gt;&gt;&gt; l1 = [1, 2]\n&gt;&gt;&gt; l2 = [3, 4]\n&gt;&gt;&gt; l2 == l2[:] == l2[::]           # Same\nTrue\n&gt;&gt;&gt; l1.extend(l2)                   # Concat the 2 lists and modify one of them in-place ! Here, l1 will be modified!\n                                    # Same as list_1 += list_2 !!   &lt;-- also list_1 keep the same id !!!\n&gt;&gt;&gt; l1\n[1, 2, 3, 4]\n&gt;&gt;&gt; l1.append(l2)                   # Append 1 element at the end of the list (l1 is modified)\n&gt;&gt;&gt; l1\n[1, 2, 3, 4, [3, 4]]\n\n&gt;&gt;&gt; l1.insert(0,\"Yes\")              # In-place insert at the beginning of the list ~ pre-pend!\n                                    # The opposite of append!\n&gt;&gt;&gt; l1[0]\nYes\n&gt;&gt;&gt; l1                              # Note that insert does NOT replace! (unlike l[0] = 'No' would!)\n['Yes', 1, 2, 3, 4, [3, 4]]]\n\n&gt;&gt;&gt; a = 5\n&gt;&gt;&gt; l3 = [1, 2, 3]\n&gt;&gt;&gt; [a] + l3                        # Insert at the beginning with '+'\n                                    # Almost same as .extend, except the original list is not changed in place!\n[5, 1, 2, 3]\n</code></pre> <pre><code>&gt;&gt;&gt; list = [1, 'deux', {'trois': 3 } ]  # A list doesn't require its elements to be different\n&gt;&gt;&gt; list = ['the','holy','grail']   # List ~ array are represented with square brackets\n&gt;&gt;&gt; nested_list = [ 'XXX', list]    # One of the elements of the list is a list\n&gt;&gt;&gt; 'XXX' in nested_list            # Check list membership\nTrue\n\n\n# The returned lists are not the original list (ie different id)\n# You cannot do l[1:].remove(3) and update the list l\n&gt;&gt;&gt; my_list[:]                      # The whole list\n&gt;&gt;&gt; my_list[0:]                     # The whole list (same as above)\n&gt;&gt;&gt; my-list[0:len(my_list)]         # The whole list (same as above)\n&gt;&gt;&gt; my_list[::1]                    # The whole list (same as above)\n&gt;&gt;&gt; my_list[2:]                     # From 3rd element to end\n&gt;&gt;&gt; my_list[2:-2]                   # From 3rd element to 2nd before last\n&gt;&gt;&gt; my_list[-1:] = [9]              # from the last element to the end\n&gt;&gt;&gt; my_list[-2:] = [8, 9]\n&gt;&gt;&gt; my_list[:-2:] = [0, 1, 2, 3, 4, 5, 6, 7]\n\n&gt;&gt;&gt; nested_list[1] = 'awesome'      # List are mutable!\n&gt;&gt;&gt; my_list.append('for sure')      # append 1 element only\n&gt;&gt;&gt; my_list.append(another_list)    # 'another_list' is placed at the end of the list as a single element\n&gt;&gt;&gt; my_list.insert(1,'super')       # inserting of an element without deletion\n&gt;&gt;&gt; my_list.remove('super')         # remove the FIRST 'super' entry from the list\n&gt;&gt;&gt; my_list = [x for x in my_list if x != 'super']  # remove all the 'super' entry\n\n&gt;&gt;&gt; my_list.extend(another_list)    # contact the 2 lists like the + operation, but my_list is changed in place!\n\n&gt;&gt;&gt; my_list.extend(another_list)      # contact the 2 lists like the + operation and change in place my_list !\n&gt;&gt;&gt; my_list = my_list + another_list  # same as above\n</code></pre> <pre><code>&gt;&gt;&gt; myList.index(\"revolves\")\n3\n&gt;&gt;&gt; \"revolves\" in myList\nTrue\n&gt;&gt;&gt; my_list.index(\"a\")\nException ValueError: 'a' is not in list\n</code></pre> <pre><code>token = string.split('\\t')      # Split on tab only\ntoken = string.split()          # Split on any space character\n</code></pre> <pre><code># Remove all the elements with a given value between 2 indexes of a list\ndef remove_between_indexes(lst, start, end, value):\n    return lst[:start] + [x for x in lst[start:end] if x != value] + lst[end:]\n\n# Example list\nmy_list = [\"keep\", \"remove_me\", \"keep\", \"remove_me\", \"keep\", \"remove_me\", \"keep\"]\n\n# Remove 'remove_me' between index 1 and 5\nnew_list = remove_between_indexes(my_list, 1, 5, \"remove_me\")\n\nprint(new_list)\n</code></pre></p>"},{"location":"python/list/#function-with-list-parameter","title":"function with list parameter","text":"<pre><code>len(lst)             - length of the list\nsorted(lst)          - &lt;!&gt; lst.sort()  &lt;== sort in place, but sorted(lst) sort the output\nsum(lst)             - sum of all the element of the list\n                     - &lt;!&gt; add to 0, so must be a number and not char/str/etc. !\nlst[::-1]            - &lt;!&gt; l.reverse() &lt;== reverse in place, but lst[::-1] reverse the output only!\n ...\n</code></pre>"},{"location":"python/list/#sorting","title":"sorting","text":"<p>. &lt;&gt;  * lst.sort change the list in place, while sorted doesn't!  * lst.sort can also use a function to sort the element of he list. see below  &lt;<p>&gt;  . &lt;!&gt; sort numbers first and then string ! ( = use LSD Radix sort first and then MSD Radix sort?)</p>"},{"location":"python/list/#sortedlst","title":"sorted(lst)","text":"<p>. &lt;!&gt; Deprecated? Use lst.sort() instead of sorted(l) ? No, lst.sort() = sort in place while sorted(lst) does not change lst!</p> <pre><code>sorted(range(30,20,-1))                                        # Turn range into a list and sort in numerical order\n\n&gt;&gt;&gt; sorted([\"a\", \"b\", \"ab\", \"z\", \"tutu\", \"aaa\", \"0\", \"2\"])     # Sort in alphabetical/dictionary order\n['a', 'aaa', 'ab', 'b', 'tutu', 'z']\n\n&gt;&gt;&gt; sorted([1, 2.3, 0.99, -23])                                # Sort in numerical/incremental order\n[-23, 0.99, 1, 2.3]\n\n&gt;&gt;&gt; sorted([1, 2, 3, 4, 'a', 'b', 2.4, 3])              # Python3 raise an exception\nTypeError: unorderable types: str() &lt; int()\n</code></pre> <pre><code># Sorting list of tuples use the first element of the tuple\n&gt;&gt;&gt; l = [ ('a',34), ('z', 23), ('b', 44)]\n&gt;&gt;&gt; sorted(l)\n[('a', 34), ('b', 44), ('z', 23)]\n\n# Sort based on 2nd field of tuple ~~~&gt; reverse tuple\n&gt;&gt;&gt; l = sorted(list(map(lambda el: el[::-1], l)))\n&gt;&gt;&gt; sorted(l)\n[(23, 'z'), (34, 'a'), (44, 'b')]\n</code></pre>"},{"location":"python/list/#lstsort","title":"lst.sort","text":"<p>. &lt;!&gt; Inplace sorting ! Not lie l2 = l1.sort() ... like sorted?</p> <pre><code>lst.sort()         # Like sorted, but change the list in place\n\nlst.sort(reverse=True)     # Sort in reverse order!\n\n&gt;&gt;&gt; list1=[[3,5,111],[16,23,21],[1,2,3,4],[100,1,31,12]]\n&gt;&gt;&gt; list1.sort(key=lambda x:x[1], reverse=True)                         # Sort based on a value extracted from each element/x!\n[[16, 23, 21], [3, 5, 111], [1, 2, 3, 4], [100, 1, 31, 12]]\n\n\n&gt;&gt;&gt; list1=[[100,200,300,400,500],[100,200,300],[100,150,200,400]]\n&gt;&gt;&gt; list1.sort(key=len)                                                 # using a FUNCTION REFERENCE to sort the elements, here the length function of the element\nprint(list1)\n[[100, 200, 300], [100, 150, 200, 400], [100, 200, 300, 400, 500]]\n\n\nlist1=[[10,200,300,40,500],[100,200,300],[100,150,200,400]]\nlist1.sort(key=sum)                                                     # using the key as sum on the element      sum([1,2]) == 3\nprint(list1)\n[[100, 200, 300], [100, 150, 200, 400], [10, 200, 300, 40, 500]]\n</code></pre>"},{"location":"python/list/#map-operation-on-every-element-of-a-list","title":"map : Operation on every element of a list","text":"<ul> <li>map() is used to execute a function on all the element of a list</li> <li>map() can also be used to work on multiple lists at once (list zip())</li> <li>if map() is using only one list as input, it can be done with a list comprehension!</li> <li> the output of map(...) is a map and not a list!</li> </ul> <p><pre><code>l = list(range(9))                  # Python3: Turn the iterator-like range into a list\nl = list(map(str, range(9))         # Python3: Turn the map object into a list\n\nl = [ ('a',34), ('z', 23), ('b', 44)]\nr = list(map(lambda el: el[::-1], l))    # [(34, 'a'), (23, 'z'), (44, 'b')]\nprint(r)\n[(44, 'b'), (23, 'z'), (34, 'a')]\n\n# Map with a function instead of a lambda!\ndef my_function(value):\n    \"\"\" Double provided value \"\"\"\n    return value + value\n\nmy_values = (1, 2, 3, 4)                # Can be a tuple or a list\nres = list(map(my_function, my_values))\n\nres = list(map(lambda v: v + v, my_values))   # Map with a lambda function !\n\n&gt;&gt;&gt; d                                   # beware list of chars, not index --&gt; string multiplication!\n['0', '1', '2', '3', '4', '5', '6', '7', '8']\n&gt;&gt;&gt; [ x*2 for x in d ]\n['00', '11', '22', '33', '44', '55', '66', '77', '88']\n\n\n# List of strings\nlist_of_strings = ['sat', 'bat', 'cat', 'mat']\n\n# map() can listify the list of strings individually\ntest = list(map(list, list_of_strings))\ntest                                    # returns [['s', 'a', 't'], ['b', 'a', 't'], ['c', 'a', 't'], ['m', 'a', 't']]\n</code></pre> <pre><code>s = 'hello world'\nlc = list(s)\n\n&gt;&gt;&gt; [ el.upper() for el in lc]\n['H', 'E', 'L', 'L', 'O', ' ', 'W', 'O', 'R', 'L', 'D']\n\n&gt;&gt;&gt; list(map(lambda el: el.upper(), lc))\n['H', 'E', 'L', 'L', 'O', ' ', 'W', 'O', 'R', 'L', 'D']\n</code></pre></p>"},{"location":"python/list/#working-with-2-lists-together-map","title":"Working with 2 lists together (map)","text":"<pre><code># Add two lists using map and lambda\n\nx_values = [1, 2, 3]\ny_values = [4, 5, 6]\n\nresult = map(lambda x, y: x + y, x_values, y_values)\n</code></pre>"},{"location":"python/list/#iteration-on-the-elements-of-a-list","title":"iteration on the elements of a list","text":"<p><pre><code>help(list.insert)\ninsert(self, index, object, /)\n    Insert object before index.\n</code></pre> <pre><code>ordered_words = ['aa', 'bb', 'ee', 'hh']\nwords = 'aaa,ddd'\n\n\ndef insert_word(word, ordered_words):\n    \"\"\" change ordered_words in place \"\"\"\n    for i, el_word in enumerate(ordered_words):\n        if word &lt; el_word:                        # Inequality on strings, sort based on ASCII characters' code! One by one chars\n            ordered_words.insert(i, word)         # Equivalent to ordered_words = ordered_words[:i] + [word] + ordered_words[i:]\n            break\n    return(true)\n\n\n\n\nwords = arg_w.split(',')\n\nfor w in words:\n    insert_word(w, ordered_words)\n\nprint ordered_words\n</code></pre></p>"},{"location":"python/list/#introspection","title":"Introspection","text":"<pre><code>&gt;&gt;&gt; l\n[9, 7, 5, 3, 1]\n\n&gt;&gt;&gt; type(l)\nlist\n\n&gt;&gt;&gt; dir(l)\n&gt;&gt;&gt; dir(list)\n['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']\n\n&gt;&gt;&gt; help(list.extend)\nextend(self, iterable, /)\n    Extend list by appending elements from the iterable.\n</code></pre>"},{"location":"python/miscellaneous/","title":"Miscellaneous","text":""},{"location":"python/miscellaneous/#title-python-fundamentals-miscellaneous","title":"title= Python Fundamentals &gt; Miscellaneous","text":""},{"location":"python/miscellaneous/#miscellaneous","title":"Miscellaneous","text":""},{"location":"python/miscellaneous/#hello-world","title":"Hello world!","text":"<pre><code>$ python3 --version\nPython 3.9.10\n\n$ python3\n&gt;&gt;&gt; print(\"Hello world!\")             # Python 3\n&gt;&gt;&gt; 2+1\n&gt;&gt;&gt; 2*(3+4)\n#!/usr/bin/env python\n#!/usr/bin/env python2      # DEPRECATED\n#!/usr/bin/env python3\n</code></pre>"},{"location":"python/miscellaneous/#data-structure-algorithm","title":"Data structure &amp; algorithm","text":"<p>Set ::</p> <p>List ::</p> <p>Map ::</p> <p>Trees ::</p> <p>Graph ::</p> <p>Big0 notiation ::</p>"},{"location":"python/miscellaneous/#check-this-site","title":"Check this site","text":"<ul> <li> <p>https://csvistool.com/</p> </li> <li> <p>https://csvistool.com/</p> </li> <li> <p>https://csvistool.com/</p> </li> </ul>"},{"location":"python/miscellaneous/#variables-scopes","title":"Variables scopes","text":""},{"location":"python/miscellaneous/#global-variables","title":"Global variables","text":"<pre><code>globvar = 0\n\ndef set_globvar_to_one():\n    global globvar    # Needed to modify global copy of globvar\n    globvar = 1\n\ndef print_globvar():\n    print(globvar)     # No need for global declaration to read value of globvar\n\nset_globvar_to_one()\nprint_globvar()       # Prints 1\n</code></pre>"},{"location":"python/miscellaneous/#name","title":"name","text":"<pre><code># mymodule.py\nprint(f\"__name__ is: {__name__}\")\n</code></pre> <pre><code># main.py\nimport module          # Outputs __name__ is: mymodule\n</code></pre>"},{"location":"python/numbers/","title":"Python Fundamentals > Numbers","text":""},{"location":"python/numbers/#numbers","title":"Numbers","text":"<p>Numbers are immutable!</p> <p>so are strings, tuples, etc.</p> <p>But beware: it is the content that is immutable, the variable that points to this content can still change!</p> <pre><code>0\n1\n1.2\n34.56\n-56.3\n\n&gt;&gt;&gt; a = 1\n&gt;&gt;&gt; id(1)\n4329177328\n&gt;&gt;&gt; id(a)\n4329177328\n\n&gt;&gt;&gt; a = 256                               # Variable is pointing to the identity of another immutable number!\n&gt;&gt;&gt; id(256)                               # If you take a higher number, the id can change !!!!\n4329185488\n&gt;&gt;&gt; id(a)\n4329185488\n</code></pre> <p>More About (im)mutability @ https://towardsdatascience.com/https-towardsdatascience-com-python-basics-mutable-vs-immutable-objects-829a0cb1530a</p>"},{"location":"python/numbers/#integer-and-float","title":"integer and float","text":"<pre><code>5 / 2 == 2.5                        # Python 3 only !\n5 // 2 == 2                         # Python 3 only (equivalent to floor) !\nmath.floor(5/2)        # rounds down towards -oo --&gt; outputs 2\nmath.floor(-5/2)       # Outputs -3     \nmath.ceil(5/2)         # rounds up towards +oo --&gt; Outputs 3\nmath.ceil(-5/2)        # rounds up towards +oo --&gt; Outputs -2 \nround(5/2)        # rounds towards 0? NO, round half (.5) to closest even --&gt; Outputs 2 (rounds down)\nround(-5/2)       # Outputs -2  &lt;-- round is symetric and round up and down (to avoid bias)\nround(7/2)        # Outputs 4 (rounds up!)\nround(-7/2)       # Outputs -4\nint(3.7)          # outputs 3  &lt;-- always round towards 0!\nint(-3.7)         # outputs -3\nmath.trunc(3.7)   # equivalent to int(3.7)\n\n# Function Returning Multiple Values (Tuple)\ndef divide(a: int, b: int) -&gt; tuple[int, int]:   # Takes two integers, returns a tuple of int\n    return a // b, a % b                         # // and % work together!\n\n\nimport math\n&gt;&gt;&gt; _pi = math.pi\n&gt;&gt;&gt; print(_pi)\n3.141592653589793\n\n&gt;&gt;&gt; g1 = round(_pi,2)                 # Rounding floats\n&gt;&gt;&gt; print(g1)\n3.14\n\n\n&gt;&gt;&gt; g2 = float(\"{1:.2f}\".format(0.1234, _pi))   # Same operation with conversion through a formatted string!\n                                        # float --&gt; turn string into float\n                                        # format string with element 1 in format (which is _pi!)\n                                        # and format it with .2f as a float with 2 digits after the comma\n&gt;&gt;&gt; g\n3.14\n</code></pre> <p>Source @ http://www.tutorialspoint.com/python/python_basic_operators.htm</p>"},{"location":"python/numbers/#bitwise-operation","title":"bitwise operation","text":"<p>&lt;!&gt; Spaces added in binary value for clarity but must be removed in real python code&lt;&gt;  &lt;!&gt; Prefix 'b' as in b\"0001\" ==&gt; bytes, prefix '0b' as in 0b0001 ==&gt; integer_coded_in_binary</p> <pre><code>a = 0b 0011 1100                  # a = 60 !\nb = 0b 0000 1101                  # b = 13 !\n-----------------\n\na&amp;b = 0b 0000 1100                 @ a AND B\n\na|b = 0b 0011 1101                 # a OR B\n\na^b = 0b 0011 0001                 # a XOR b\n                                   # Note that 2^2 is not 2**2 !!\n\n~a  = 0b 1100 0011                 # NOT a\n</code></pre> <p>Source @ http://www.tutorialspoint.com/python/python_basic_operators.htm</p>"},{"location":"python/numbers/#byte","title":"byte","text":"<pre><code>two_bytes = b'\\x01\\x02'\nnumber = int.from_bytes(two_bytes, byteorder='big')      # Interprets as 258 (1*256 + 2)\nprint(number)\n\nnumber = 258\nbytes_obj = number.to_bytes(2, 'big')  # Outputs: b'\\x01\\x02'\nprint(bytes_obj)\n</code></pre> <pre><code>byte1 = b'\\x05'\nbyte2 = b'\\x03'\n\n# Extract the integer values (5 and 3)\nvalue1 = byte1[0]\nvalue2 = byte2[0]\n\n# Perform arithmetic addition\nsum_value = value1 + value2  # 5 + 3 = 8\nprint(sum_value)  # Outputs: 8\n\n# Optionally, convert the result back to a bytes object (if it fits in one byte)\nresult_byte = sum_value.to_bytes(1, 'big')\nprint(result_byte)  # Outputs: b'\\x08'\n</code></pre>"},{"location":"python/numbers/#introspection","title":"introspection","text":"<pre><code>&gt;&gt;&gt; i = 17\n&gt;&gt;&gt; type(i)\n&lt;class 'int'&gt;\n\n&gt;&gt;&gt; dir(45)\n['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'real', 'to_bytes']\n\n&gt;&gt;&gt; help(int.to_bytes)\n... shows method descriptor ...\n\n&gt;&gt;&gt; i.to_bytes(2,\"big\")        # 2-byte representation\n                               # 'big', the most significant byte is at the beginning of the byte array.\nb'\\x00\\x11'\n\n&gt;&gt;&gt; i.to_bytes(4,\"big\")\nb'\\x00\\x00\\x00\\x11'\n&gt;&gt;&gt; i.to_bytes(4,\"little\")\nb'\\x11\\x00\\x00\\x00'\n</code></pre>"},{"location":"python/object/","title":"Intermediate Python > Object","text":""},{"location":"python/object/#object","title":"Object","text":"<pre><code>class Vector2D:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        if isinstance(other, Vector2D):\n            return Vector2D(self.x + other.x, self.y + other.y)\n        return NotImplemented\n\n    def __mul__(self, scalar):\n        if isinstance(scalar, (int, float)):\n            return Vector2D(self.x * scalar, self.y * scalar)\n        return NotImplemented\n\n    def __rmul__(self, scalar):\n        return self.__mul__(scalar)  # for scalar * vector\n\n    def __repr__(self):\n        return f\"Vector2D({self.x}, {self.y})\"\n</code></pre>"},{"location":"python/range/","title":"Python Fundamentals > Range","text":""},{"location":"python/range/#range","title":"Range","text":"<p>Not quite an iterator</p> <p>Range are iterator-like but not iterator, because they do not keep track of their state</p> <ul> <li>range is an iterable (not an iterator) that generates numbers lazily (when asked for it).</li> <li>You need to call iter(range(n)) to get an iterator from it (and get the 'next' method).</li> </ul> <p><pre><code>r = range(3)\nprint(next(r))  # \u274c TypeError: 'range' object is not an iterator\n</code></pre> <pre><code>r = iter(range(3))  # Creates an iterator from range   (call range.__iter__ method)\nprint(next(r))  # 0\nprint(next(r))  # 1\nprint(next(r))  # 2\nprint(next(r))  # \u274c Error! StopIteration\n</code></pre></p> <ul> <li>Using range is memory-efficient compared to storing a full list.</li> </ul>"},{"location":"python/set/","title":"Python Fundamentals > Set","text":""},{"location":"python/set/#set","title":"Set","text":"<p>Sets are Unordered immutable elements with no duplicate.</p> <p>Sets are mutable</p> <p>What is a set:</p> <ul> <li>Every element in set is unique (no duplicates)</li> <li>Sets can be used to perform mathematical set operations like union, intersection, symmetric difference etc.</li> <li> Every element in set must be immutable (which cannot be changed) like strings, numbers, tuple, or range, however, the set itself is mutable. We can add or remove items from it.</li> </ul> <p>More at @ https://www.thegeekstuff.com/2019/04/python-set-examples/#more-17819</p>"},{"location":"python/set/#hands-on","title":"Hands-on","text":"<p><pre><code>Months={\"Jan\", \"Feb\", \"Mar\", \"Feb\"}                  # Will remove 1 \"Feb\" because not unique!\nDates={21,22,17}\n\n&gt;&gt;&gt; type(Dates)\nset\n\nDays = set([\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\",\"Sun\"])   # Turn a list in a set\n\n&gt;&gt;&gt; cars = ['honda','ford','dodge', 'honda']            # List\n&gt;&gt;&gt; autos = set(cars)                                   # Create a set from a list\n&gt;&gt;&gt; autos\nset(['dodge',chevy','honda', 'ford'])\n&gt;&gt;&gt; motos &amp; autos                                       # intersection of sets\n&gt;&gt;&gt; employees = engineers | programmers | managers      # union of sets\n&gt;&gt;&gt; engineering_management = engineers &amp; managers       # intersection of sets\n&gt;&gt;&gt; managers_only = employeses - engineers - programmers  # difference of sets\n</code></pre> <pre><code>s.update(t)                   # s |= t  return set s with elements added from t\ns.intersection_update(t)          # s &amp;= t  return set s keeping only elements also found in t\ns.difference_update(t)            # s -= t  return set s after removing elements found in t\ns.symmetric_difference_update(t)  # s ^= t  return set s ...\n                                  # ... with elements from s or t but not both\n\ns.add(x)       # add element x to set s (if x is not already there! If already there, tihs is a no-op!)\ns.remove(x)        # remove x from set s; raises KeyError if not present\ns.discard(x)       # removes x from set s if present (no exception)\ns.clear()          # remove all elements from set s\n\ns.pop()            # remove and return an arbitrary element from set s ...\n                   # ... raises KeyError if empty\n</code></pre></p> <p>Source @ [[https://docs.python.org/2/library/sets.html||target='_blank']]</p>"},{"location":"python/set/#introspection","title":"Introspection","text":"<pre><code>&gt;&gt;&gt; s = set()\n&gt;&gt;&gt; type(s)\nset\n\n&gt;&gt;&gt; dir(s)\n&gt;&gt;&gt; dir(set)\n['__and__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__iand__', '__init__', '__ior__', '__isub__', '__iter__', '__ixor__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__or__', '__rand__', '__reduce__', '__reduce_ex__', '__repr__', '__ror__', '__rsub__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__xor__', 'add', 'clear', 'copy', 'difference', 'difference_update', 'discard', 'intersection', 'intersection_update', 'isdisjoint', 'issubset', 'issuperset', 'pop', 'remove', 'symmetric_difference', 'symmetric_difference_update', 'union', 'update']\n\n&gt;&gt;&gt; help(set.update)\nupdate(...)\n    Update a set with the union of itself and others.\n</code></pre>"},{"location":"python/strings/","title":"Python Fundamentals > Strings","text":""},{"location":"python/strings/#strings","title":"Strings","text":""},{"location":"python/strings/#immutability","title":"Immutability","text":"<p>A string ~= immutable tuple of characters</p> <p>In Python, immutability refers to the property of an object that cannot be changed after it is created.</p> <pre><code>\"hello\" ~= ('h', 'e', 'l', 'l', 'o' )\n</code></pre> <p>Well, not exactly because their types are different, one is 'str' while the other is 'tuple'. They are also different objects, with different methods!</p> <pre><code>type('hello')                       # &lt;class 'str'&gt;\ntype(('h', 'e', 'l', 'l', 'o'))     # &lt;class 'tuple'&gt;\n</code></pre> <ul> <li>Strings are immutable in python (see replace) as are number (int, float, decimal), bool,  tuple, and range!</li> <li>What is immutable is the content of the string, the variable can be reassigned!</li> </ul> <p>What is unicode and utf-8 @ https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/</p> <p>Demonstration of immutability</p> <p><pre><code>&gt;&gt;&gt; text = \"Data Science\"\n&gt;&gt;&gt; print(id(text))\n2450343168944                            # also = to id(\"Data Science\") ;-)\n\n&gt;&gt;&gt; text += \" with Python\"\n&gt;&gt;&gt; print(id(text))\n2450343426208                            # The variable points to a new identity (~pointer)\n</code></pre> Source @ https://towardsdatascience.com/https-towardsdatascience-com-python-basics-mutable-vs-immutable-objects-829a0cb1530a</p> <pre><code>our_str ='Bonjour Monde'\nour_str = 'Hello World'                         # Override variable &lt;&gt; immutability of pointed content\n\nprint(our_str[0])                               # At a given index, you can read, but you cannot write!\n# our_str[0] = 'h'                              # Exception: TypeError: 'str' object does not support item assignment\n# our_str[0] = our_str[0].lower()               # Exception! Strings are immutable\nnew_str = our_str.replace('World', 'Jackson')   # HERE we create a new string, the old string is not changed!\n</code></pre>"},{"location":"python/strings/#hands-on","title":"Hands-on","text":"<pre><code># &lt;!&gt; sorted(string) return a sorted list of characters contained in string\n# &lt;!&gt; This list needs to be turned into a string using join()!\nordered_chars_LIST = sorted(string_of_unordered_chars)       # returns an ordered LIST or characters , not a string but a LIST!\nordered_chars = ''.join(sorted(unordered_chars))   # Order a string (anagram)\n\n\nstring1 = \"this is a string\"\nstring2 = \"%s! %s\" % (\"hello\",\"toto\")                             # Print a string in a string!\nstring3 = \"%(h)s! %(n)s\" % { \"n\":\"toto\", \"h\":\"hello\"}             # Using named variable from a dictionary (great for templating!)\n\nstring4 = \"a number y is {1:.2f} and x is {0:.3f}\".format(x, y)   # order from tuple followed by format!\n\nprice = 4.55\nstring5 = f\"Price in Swiss Franks: {price * 1.086:5.2f}\"          # String literal &lt;!&gt; 'price' variable must exists\n                                                                  # Don't forget the 'f' at the beginning of the string!\n\nstr(3210)                                  # Convert number to string '3210'\nstr(\"hello\")                               # Convert a string into a string, i.e. do nothing!\n\nfloat(\"3.1415\")                            # Turn a string to float\nint(\"3\")                                   # Turn a string to a integer\n# int(\"3.1415\")                            # &lt;!&gt; This is an error as this is a float\nint(float(\"3.14\"))                         # &lt;!&gt; Ok, this works! ;-) and is 3\n\nstring3 = string1 + string2                # Concatenation operation\nmultiline = \"This is a \\n\\\n... multiline string\"                      # Multiline string\n#comment\nlen(var3)                                  # Length of a string\n\n\nprint(program, \"arguments\")                # Python3\nprint(program, \"arguments\", sep=\" \", end=\"\\n\")    # Python3 equivalent = Concat 2 strings with a space in between + CR at the end\n\n\n&gt;&gt;&gt; list(\"hello world\")                    # A string = tuple of chars --&gt; turn a tuple of char into a list!\n['h', 'e', ...., 'o', ' ', 'w', ..., 'd']\n\n# &lt;!&gt; Strings are immutable, but here you are just changing where the variable points to, not the string\ns = s.lstrip()                             # Remove leading spaces\ns = s.rstrip()                             # Remove trailing spaces and CARRIAGE RETURNS\ns = s.strip()                              # Remove leading and trailing spaces and CARRIAGE RETURNS\n\ntitle = title.strip(',.-\\n')               # Remove leading and trailing characters\n                                           # &lt;!&gt; Will strip any of those characters, not the string \",.-\" but individual characters!\n\nnumber_of_ts = s.count('t')                # Return number of character 't' in the string\nnumber_of_totos = s.count('toto')          # Return number of substrings\n\npos_of_first_t = s.find('t')\npos_of_second_t = s.find('t', pos_of_first_t)     # Find returns the index of first found 't' (or second t since starting from 1st 't' position)\n                                                  # If find reaches the end, then returns -1\n\ns.capitalize()\ns.join()\ns.split()                    # Split on any-block of spaces/tabs\n                             # , e.g. \"12    3 4\" --&gt; ['12', '3', '4']\n# s.split('')                # &lt;!&gt; but this ~~~&gt; ValueError: empty separator!\n# s.split(\"\")                # &lt;!&gt; but this ~~~&gt; ValueError: empty separator!\ns.split(\"\\t\")                # split on tab characters (\\t is the tab character, not 2 chars!)\ns.split(\" \")                 # split on space charactes only, not tabs!\n\"hello world\".split(\"wo\")    # split on a GROUP of characters &lt;!&gt; Not like strip, which assume individual characters\n\"arn::account::region\".split(\"::\")    # returns a list!\n\n# Replace = split and join?\narn = \"arn::account::region\"\narn = \"XX\".join(arn.split(\"::\"))\n=?= arn.replace(\"::\",\"XX\")            # ?\n\n&gt;&gt;&gt; s.translate(None, \",!.;\")          # Remove unwanted characters, here the punctuation\n\n&gt;&gt;&gt; \"Python\".center(10)\n'  Python  '\n\ns.endswith('toto')\ns.startswith('toto')\n\ns = \"one\\ttwo\\t\\tthree\\nfout\"      # Tabs and other special characters in a string\nprint(s)                           # Transform tabs and other special characters\n\nstring_content = \"line 1\\nline 2\\nline 3\\n\"\nstring_file_content.splitlines()             # ~ s.split('\\n') ?\n[ 'line 1', 'line 2', 'line 3']\n\n&gt;&gt;&gt; account_number = \"43447879\"\n&gt;&gt;&gt; account_number.zfill(12)             # Zero fill\n'000043447879'\n&gt;&gt;&gt; account_number.rjust(12,\"0\")         # Right justification\n'000043447879'\n\n                                         # &lt;!&gt; Immutability: can only be read\nstring[0]                                # first character\nstring[-1]                               # very last character\nstring[1:4]                              # a slice\nstring[10:]                              # a slice to end of string\nstring[:-1]                              # everything but last character\nstring[:]                             # copy of string\nstring[::1]                           # copy of string, step of 1 (default)\nstring[::2]                           # print every other characters!\nstring[::-1]                          # reverse string, step of -1\n\nstring[::-2]                          # reverse string + take every other characters\n\ns = \" a very long string ..... \"         # pep8 compliance for long string\ns =(\n  \"a very long\"\n  \"string ... \"\n)\n\ns = \"\"\"\n    A multi-line string\n    With space as well\nand carriage returns\n\"\"\"\n\ns                      # '\\n    A multi-line string\\n    With space as well\\nand carriage returns\\n'\n\nprint(s)                # \n                        #   A multi-line string\n                        #   With space as well\n                        # and carriage returns\n</code></pre>"},{"location":"python/strings/#operations","title":"Operations","text":"<pre><code>print(\"12\" + \"34\")      # Outputs: \"1234\"\nprint(\"12\" * 2)         # Outputs: \"1212\"\n</code></pre> <p>Equality/Inequality used for sorting list of strings with sorted!</p> <pre><code>(\"a\" &lt; \"b\")   is True   # True\n(\"a\" &lt; \"aaa\") is True   # True\n(\"1\" &lt; \"a\")   is True   # True\n(\"aaa\" &lt; \"a\") is False  # True, it is False ;-)\n\n# Sorting based on ASCII code of characters!\nout = sorted([\"aaa\", \"b\", \"a\", \"2\", \"-1\", \"0\"])\nprint(out)              # Outputs: [\"-1\", \"0\", \"2\", \"a\", \"aaa\", \"b\"]\n#\n</code></pre>"},{"location":"python/strings/#print-format-and-string-literal","title":"Print, format, and string literal","text":"<p> % is an operation on string!</p> <p><pre><code>print(word)\nprint(word, end='\\n')                # Same as above (default)\nprint(word, end='')                  # Print without \\n\n\nprint(pyObject)                      # Use the __str__ method or if missing the __repr__ method\nprint(\"%s\" % pyObject)               # Use the __str__ method or if missing the __repr__ method as well and ...\n                                     # ... the module operator of string class!)\n                                     # &lt;!&gt; __repr__ method is used for representation of the object in ipython when '&gt;&gt;&gt; object'\n\nprint(word.__repr__())               # Print single quoted string as word.__repr__() is \"'hello'\"\nprint(str(pyObject))                 # Convert using the __str__ method\n                                     # &lt;-- this is the correct one!\n\nprint('a very very '\n'very vreey '\n'very long ine'\n)\n</code></pre> <pre><code>s = 'hello world!'\npi = 3.1415\nprint(f's is {s} and pi is {pi:.2}')          # String literal\n                                              # &lt;!&gt;  do not forget the 'f' before the quote otherwise not expended!\nprint(f's is {s} and pi is {pi:.2f}')         # &lt;!&gt; also do not forget the f in the formatting of pi to indicate a float\n                                              # the first line prints 3.1 and the second 3.14 for the value of pi !!!\n</code></pre> <pre><code>&gt;&gt;&gt; print(q, p, p * q, sep= \" \", end=\"\\n\")      # (default) sep -&gt; separator     end -&gt; CR\n&gt;&gt;&gt; print(q, p, p * q, sep=\" :-) \", end=\"\")     # sep -&gt; separator     end -&gt; no carriage return\n459 :-) 0.098 :-) 44.982\n</code></pre></p> <p>FORMAT</p> <p> The pythonic way to print strings, because strings are objects!</p> <pre><code>&gt;&gt;&gt; print(\"average is {f}\".format(average, f=1))     # here f is a MIX of variables + named arguments\naverage is 1                                         # &lt;!&gt; 1 is not the DEFAULT value for f, but the constant value of f !\n                                                     # f is a keyword argument (a variable to be called in the formatted string)\n\n&gt;&gt;&gt; print(\"average is {:f}\".format(average, f=1))    # here f is formatting of DEFAULT first element, i.e 0, as a float\n                                                     # &lt;!&gt; if {} were to reappear in the string, it would point to the second element (which does not exist here)\n                                                     # {} points to the first element only when appear first, then the counter is incremented!\naverage is 2.300000\n&gt;&gt;&gt; print(\"average is {0:f}\".format(average, f=1))    # here f is formatting of element 0 (float) - same as above but more explicit!\naverage is 2.300000\n&gt;&gt;&gt; &gt;&gt;&gt; print(\"average is {1:f}\".format(average, 3.4, f=1.2))    # here 3.4 is element at pos 1\naverage is 3.400000                                              # Is f=1.2 at pos 2? NO! 'f' = keyword argument (**kwargs), while average and 3.4 are positional args (*args)\n\n# &gt;&gt;&gt; print(\"average is {1:f}\".format(average, f=1))    # IndexError: Replacement index 1 out of range for positional args tuple\n                                                        # Tuple *arg vs **kargs dict ? Yes!\n\n&gt;&gt;&gt; f = 1\n&gt;&gt;&gt; print(\"average is {1:f} {0:f}\".format(average, f))  # the last f is the value of the variable 'f' and is a positional argument of the format method\n\n\n&gt;&gt;&gt; x = 3.1415\n&gt;&gt;&gt; float(\"{0:.2f}\".format(x))                 # don't forget the 'f' for float!\n3.14\n\n&gt;&gt;&gt; print(\"{:d}\".format(7000))\n7000\n&gt;&gt;&gt; print(\"{:,d}\".format(7000))\n7,000\n&gt;&gt;&gt; print(\"{:^15,d}\".format(7000))              # 15 is total number of characters, 7,0000 is centered\n     7,000\n&gt;&gt;&gt; print(\"{:*^15,d}\".format(7000))\n*****7,000*****\n&gt;&gt;&gt; print(\"{:*^15.2f}\".format(7000))\n****7000.00****\n&gt;&gt;&gt; print(\"{:*&gt;15,d}\".format(7000))\n**********7,000\n&gt;&gt;&gt; print(\"{:*&lt;15,d}\".format(7000))             # left alignment\n7,000**********\n&gt;&gt;&gt; print(\"{:*&gt;15X}\".format(7000))              # right alignment\n***********1B58\n&gt;&gt;&gt; print(\"{:*&lt;#15x}\".format(7000))             # hexadecimal format\n0x1b58*********\n\n\nif not testbed:\n        raise Exception(\"No such testbed {}\".format(testbed_name))\n\n&gt;&gt;&gt; '{0}{1}{0}'.format('abra', 'cad')                  # arguments' indices can be repeated\n'abracadabra'                                          # ~ format of a tuple, and index in the tuple\n\n&gt;&gt;&gt; 'Coordinates: {latitude}, {longitude}'.format(latitude='37.24N', longitude='-115.81W')  # With named arguments\n'Coordinates: 37.24N, -115.81W'\n&gt;&gt;&gt; \"Art: {a:5d},  Price: {p:8.2f}\".format(a=453, p=59.058)\n'Art:   453,  Price:    59.06'\n\n&gt;&gt;&gt; print(\"I've &lt;{}&gt; years of experience and my salary is &lt;{:,}&gt; USD per annum.\".format(10, 75000))  # {} points to first and then {} points to second element\nI've &lt;10&gt; years of experience and my salary is &lt;75,000&gt; USD per annum.\n\n&gt;&gt;&gt; data = dict(province=\"Ontario\",capital=\"Toronto\")\n&gt;&gt;&gt; data\n{'province': 'Ontario', 'capital': 'Toronto'}\n&gt;&gt;&gt; print(\"The capital of {province} is {capital}\".format(**data))         # With a dictionary\n                                                                           # SWEET **kwargs --&gt; **dictionary !!!\n\n\"{0:&lt;20s} {1:6.2f}\".format('Spam &amp; Eggs:', 6.99)                           # With anchored strings\n'Spam &amp; Eggs:           6.99'\n\n\n&gt;&gt;&gt; class Point(object):\n...     def __init__(self, x, y):\n...         self.x, self.y = x, y\n...     def __str__(self):\n...         return 'Point({self.x}, {self.y})'.format(self=self)          # with objects\n...     def __repr__(self):\n...             return 'REPR Point({self.x}, {self.y})'.format(self=self)\n...\n&gt;&gt;&gt; str(Point(4, 2))\n'Point(4, 2)'\n&gt;&gt;&gt; Point(4,2)\nREPR Point(4, 2)\n</code></pre> <p>Source @ https://www.python-course.eu/python3_formatted_output.php</p> <p>More @ https://www.techbeamers.com/python-format-string-list-dict/</p> <p>SHORT FORMAT (aka string literal -- see above)   * &lt;!&gt; If variable does not exist ---&gt; Exception: !NameError: name 'ss' is not defined</p> <pre><code>def greet(name):\n    print(f\"Hello {name}\")           # aka string literal\n</code></pre>"},{"location":"python/strings/#print-in-a-file","title":"Print in a file","text":"<pre><code>from __future__ import print_function\n\ns = 'hello world!'\n# f = open(\"file.txt\", \"a\")\nwith open(\"file.txt\", \"a\") as f:\n    print(s, end=\"\", file=f)            # Python3\n</code></pre> <p>Source @ https://stackoverflow.com/questions/9236198/python-3-operator-to-print-to-file</p>"},{"location":"python/strings/#conversion","title":"Conversion","text":"<ul> <li> List are indexed at 0</li> <li> spliting a list gives you a list of string which you need to reformat </li> </ul> <pre><code>abc = \"abcde....z\"        # A string is an immutable tuple of characters\nchar_list = list(abc)\n\n\ns = 'afdadf 5 dfad 5.0 dfdsdf'\n# token = s.split(' ')          # Split on space character\ntoken = s.split()               # Split on any space char, including tab and multiple space\nsum = sum + int(token[1]) + float(token[3])   # sum = sum + 5 + 5.0\n</code></pre>"},{"location":"python/strings/#char-in-strings-char-string-of-len-1","title":"Char in strings (char = string of len 1)","text":"<p>Char is a string of length 1 !</p> <pre><code>abc = \"abcde....z\"          # sring = an immutalbe tuple of characters!\nchar_list = list(abc)\n\n&gt;&gt;&gt; type('a')\n&lt;class 'str'&gt;\n&gt;&gt;&gt; chr(97)\n'a'\n&gt;&gt;&gt; ord('a')              # works only on string of length 1\n97\n\ntype(chr(97))             # &lt;class 'str'&gt;\n\n&gt;&gt;&gt; s = \"asjo,fdjk;djaso,oio!kod.kps\"\n&gt;&gt;&gt; s.translate(None, \",!.;\")          # Remove unwanted characters\n'asjofdjkdjasooiokodkjodsdkps'\n\nlist('cat')                            # Turn a list in list of chars\n['c', 'a',''t' ]\n\n\n&gt;&gt;&gt; for char in \"python\":              # iterate on the char\n...     print(char)\n\n&gt;&gt;&gt; for char in list(string):    # string --&gt; list of chars (same as above)\n    print(char)\n\nfor pos, char in enumerate(string):         # With index/position!\n    print(pos, char)\n    print(pos, char, sep=' ', end='\\n')     # same as above (with explicit default values!)\n</code></pre>"},{"location":"python/strings/#words-in-string-not-regex","title":"Words in string (not regex)","text":"<p> Instead of regex, use method or operations of strings</p> <pre><code>new_str = our_str.replace('World', 'Jackson')    # Don't change the same string\n                                                 # &lt;!&gt; strings are immutable!\n\nif \"blah\" in \"otherstringblahtoto\": \n    print('found group of chars')\n\ns = 'tatatititata'\nif s.find('toto') == -1:\n    print(\"Not found!\")\n\ns.find('ata')                  # return the position of the first occurence\n\n\ns = \"worl\"\nS = \"Hello world!\"\n&gt;&gt;&gt; S.find(s)\n7\n\ns.endswith('toto')\ns.startswith('toto')\n\nwith open(\"myfile\", r) as file:\n\n    # for line in file.readlines():\n    for line in file:                               # readlines from files (.readlines is implied)\n        # print(line)\n        # print(line, end='\\n')                     # Same as line above, but &lt;!&gt; the line also includes a carriage return! ==&gt; 2 carriage returns!\n        print(line, end='')                         # Here we remove the extra carriage return added by the print statement!\n        print(line.rstrip())                        # Here we remove the \\n from the string, but add the one from the print!\n\nfor word in string.split():                         # Process words one at a time (split on spaces)\n    print(word, end='')                             # (Python3)\n</code></pre> <p>REGEX overkill!</p> <pre><code># Using regex module!\nimport re\nwords = re.split('\\W+', 'Words1, words2, words3.')   # \\W+ matches **one or more non-word characters**\nprint(words)               # Outputs ['Words', 'words', 'words', '']\n</code></pre>"},{"location":"python/strings/#str-method-of-classesobjects","title":"Str method of Classes/Objects","text":"<pre><code>&gt;&gt;&gt; class Point(object):\n...     def __init__(self, x, y):\n...         self.x, self.y = x, y\n...     def __str__(self):\n...         \"\"\"Used for string conversion, i.e. str(point) or print(point) or '%s' % point \"\"\"\n...         return 'Point({self.x}, {self.y})'.format(self=self)\n...     def __repr__(self):\n...         \"\"\"Used for repr(point) or in ipython when &gt;&gt;&gt; P\n...            but is also used whenever the __str__() method would normally be used and when not defined/present!\"\"\"\n...         return('toto')\n...\n&gt;&gt;&gt; str(Point(4, 2))\n'Point(4, 2)'\n</code></pre> <p>More @ https://docs.python.org/2/library/string.html</p>"},{"location":"python/strings/#variables-slicing","title":"variables, slicing","text":"<pre><code>2/ STRING, VARIABLES, SLICING\n\n#!/usr/bin/env python\n\nword = input(\"Enter a word: \")                          # python 3\nprint(word[1:] + word[0] + 'ay')\n</code></pre>"},{"location":"python/strings/#user-input","title":"user input","text":"<pre><code>language = input('Enter language')              # Python3 \nif language in ['C++', 'Python', 'Java']:\n   print(language, \"rocks!\")\nif language not in [ 'French', 'English']:\n   print(language, \"sucks!\")\n</code></pre>"},{"location":"python/strings/#introspection","title":"Introspection","text":"<ul> <li>&lt;!&gt; used a variable 's' or the type 'str', but not the value of the variable i.e. not 'dir('toto'.replace)</li> </ul> <pre><code>&gt;&gt;&gt; s = 'toto'\n\n&gt;&gt;&gt; type(s)\nstr\n\n&gt;&gt;&gt; dir(s)\n['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']\n\n&gt;&gt;&gt; help(s.split)\nsplit(sep=None, maxsplit=-1) method of builtins.str instance\n...\n</code></pre>"},{"location":"python/tuple/","title":"Python Fundamentals > Tuple","text":""},{"location":"python/tuple/#tuple","title":"Tuple","text":""},{"location":"python/tuple/#immutability","title":"Immutability","text":"<p>Some objects contain references to other objects, these objects are called containers. Some examples of containers are a tuple, list, and dictionary. The value of an immutable container that contains a reference to a mutable object can be changed if that mutable object is changed. &lt;&gt;. <p>Immutability</p> <ul> <li>&lt;!&gt; What is immutable is the content of the tuple, the variable can be reassigned!</li> <li>&lt;!&gt; other immutable types are int, float, decimal, bool, string, tuple, and range.</li> </ul> <p>More @ https://www.thegeekstuff.com/2019/03/python-tuple-examples/#more-17801</p> <ul> <li>&lt;!&gt; TUPLES ARE IMMUTABLE (Value cannot be changed) as are string and numbers</li> <li>&lt;!&gt; TUPLES ARE CONTAINER OBJECT, ex tuple of list</li> </ul> <p>Example</p> <pre><code>t = ([1,2], [0])\nid(t[0])                  # identity of t[0] is 4368558656\nt[0].append(3)            # Here we are not changing the tuple t[0] reference! We are changing the value of the list t[0] is pointing to!\nprint(t)                  # ([1, 2, 3], [0])     &lt;== Value of list in t[0] has changed!\nid(t[0])                  # identity of t[0] is 4368558656   &lt;== id has NOT changed!\n</code></pre> <p>But</p> <pre><code>&gt;&gt;&gt; t[0] = 1                 # t[0] can only point to the particular list it was initialized to!\nTypeError: 'tuple' object does not support item assignment\n</code></pre>"},{"location":"python/tuple/#hands-on","title":"Hands-on","text":"<p><pre><code>tuple = ([0,1,2], 'two', 'three')\ntuple = [0,1,2], 'two', 'three'       # Same as above without the parentheses!\ntuple                                 # ([0, 1, 2], 'two', 'three')\n\nid(tuple)                       # 4368483584  &lt;-- identity the variable points to\n\ntuple[::-1]                        # reverse a tuple! But immutability?!?!?\n                                   # The identities have not changed in the original tuple!\n('three', 'two', [0, 1, 2])        # Here we are just printing/displaying a new tuple!\n\ntuple = tuple[::-1]            # Now the variable points to a new immutable tuple\nid(tuple)                      # 4364976768 or different from the previous one!\n\n&gt;&gt;&gt; print(tuple[1])\n\n&gt;&gt;&gt; tuple[1] = 'deux'              # BEWARE IMMUTABILITY !\n                                   # Value cannot change! (Assignment)\nTypeError: 'tuple' object does not support item assignment\n\n&gt;&gt;&gt; tuple = ('three', 'two', [0, 'w', 2])\n&gt;&gt;&gt; tuple\n('three', 'two', [0, 'w', 2])\n&gt;&gt;&gt; tuple[2][1] = 'w'              # Here you change the mutable type (list) in the tuple\n                                   # , but the identity (~pointer) as seen by the tuple is still the same!\n\n&gt;&gt;&gt; tuple[1][1] = 'deux'           # Fails because string are immutable, so the id(.) would have to change\n&gt;&gt;&gt; tuple[2][1] = 'y'              # Works because the id in the list changes, but the id seen by the tuple, doesn't\n\n&gt;&gt;&gt; for el in tuple:               # This is what cannot change, the ids(~pointer) in the tuple!\n    ...:     print(id(el))\n    ...:\n140640316455304\n140640317363736\n140640317362392\n</code></pre> <pre><code>nested_tuple = (1,2), (3, 4)           # A tuple of tuple\nnested_tuple[1][1]                     # 4\nnested_tuple                           # ((1, 2), (3, 4))\n\n\n\n!!! Tuples are seen in function\ndef myfunc(self, *args, **kwargs) :    # args is a tuple, kwargs is a dict\n                                       # args = arguments\n                                       # kwargs = keyword_arguments\n</code></pre></p>"},{"location":"python/tuple/#zip","title":"zip","text":"<p><pre><code>#!/usr/bin/env python\n\nnames = [\"Alice\", \"Bob\", \"Charlie\", \"Emmanuel\"]\nages = [25, 30, 35]\n\n# Using zip\nzipped = zip(names, ages)            # When the iterables passed to zip() are of unequal length, it stops when the shortest iterable is exhausted.\n\n# Converting to a list to see the output\nprint(list(zipped))\n\n# [('Alice', 25), ('Bob', 30), ('Charlie', 35)]\n</code></pre> <pre><code>#!/usr/bin/env python \n\nnames = [\"Alice\", \"Bob\", \"Charlie\", \"Emmanuel\"]\nages = [25, 30, 35]\n\nfor name, age in zip(names, ages):\n    print(f\"{name} is {age} years old.\")\n\n# Alice is 25 years old.\n# Bob is 30 years old.\n# Charlie is 35 years old.\n</code></pre></p> <pre><code># Zip vs map\n# Zip is more readable\n# map() stops at the shortest iterable, just like ip()\n# map() version is slightly slower and more awkward!\na = [1, 2, 3]\nb = ['a', 'b', 'c']\n\nz1 = list(zip(a, b))\nz2 = list(map(lambda *args: args, a, b))\n\nprint(z1)  # [(1, 'a'), (2, 'b'), (3, 'c')]\nprint(z2)  # [(1, 'a'), (2, 'b'), (3, 'c')]\n</code></pre>"},{"location":"python/tuple/#introspection","title":"Introspection","text":"<pre><code>&gt;&gt;&gt; t = (1,2)\n\n&gt;&gt;&gt; type(t)\ntuple\n\n&gt;&gt;&gt; dir(t)\n['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'index']\n\n&gt;&gt;&gt; help(t.index)\n\nnestedtuple.index((3,4))            # Where the element can be found &lt;!&gt; only first level element!\n1\n</code></pre>"},{"location":"seaborn/","title":"Seaborn","text":"Function Purpose sns.barplot() Bar charts with statistical aggregation sns.histplot() Histograms for distribution visualization sns.boxplot() Box-and-whisker plots for outlier detection sns.violinplot() Combines boxplot and KDE for distribution sns.scatterplot() Scatter plots for relationships sns.lineplot() Line graphs for trends over time sns.heatmap() Correlation heatmaps &amp; matrix visualizations sns.pairplot() Scatterplot matrix for pairwise relationships sns.lmplot() Linear regression plots <p>All the code below can be cut-and-pasted in single cells in https://colab.research.google.com/</p>"},{"location":"seaborn/#barplot","title":"Barplot","text":"<pre><code>import matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\n\n# Sample Data\ndata = pd.DataFrame({\n    \"category\": [\"A\", \"B\", \"C\", \"D\"],     # First dataframe's column\n    \"values\": [10, 15, 7, 12]             # Second dataframe's column\n})\n\n# Create Bar Plot\nsns.barplot(x=\"category\", y=\"values\", data=data)\n\n# Show the Plot\nplt.show()\n</code></pre>"},{"location":"seaborn/#heatmap","title":"Heatmap","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\n\n# Create a DataFrame\ndata = pd.DataFrame(np.random.rand(5, 5), columns=[\"A\", \"B\", \"C\", \"D\", \"E\"])  # (1)!\n\n# Heatmap using DataFrame\nsns.heatmap(data, annot=True, cmap=\"YlGnBu\")  # (2)!\n\nplt.show()\n</code></pre> <ol> <li>np.random.rand(5, 5): Generates a 5x5 matrix of random values between 0 and 1.</li> <li>sns.heatmap(): Creates the heatmap.     annot=True: Displays numerical values inside the cells.     cmap=\"coolwarm\": Sets the color map (you can try others like \"viridis\", \"Blues\", \"magma\", etc.)</li> </ol>"}]}